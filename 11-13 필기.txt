■ 목차

	5. 파티션 테이블 생성 및 관리
	6. 기타튜닝벙법 (sql 변경)  ---> 중급 기술자와 고급 기술자의 차이


■ 파티션 테이블 생성 및 관리

	* 목차
		1. 테이블 파티셔닝
		2. 파티션 pruning
		3. 인덱스 파티셔닝


	※ 파티셔닝이란 ?

		파티셔닝은 테이블 또는 인덱스를 파티션 단위로 나누어서 저장하는 것을 말한다.
		테이블을 파티셔닝 하면 하나의 테이블일지라도 파티션 키에 따라 물리적으로 별도의 세그먼트에 
		데이터가 저장된다. ( 물리적으로 다른 공간에 저장)

		그림 : 옷장 서랍
			봄 여름 가을 겨울 옷을 따로 다른 서랍(partition)에 저장해 두면 검색속도가 빨라진다.
			해당 파티션만 검색하면 되기 때문에 성능이 좋아진다.

		파티셔닝을 왜 사용하는 것인가?
			빠르게 data를 검색하기 위해서


	※ 파티셔닝의 장점

		1. 관리적 측면 : 보관주기가 지난 data들을 별도로 백업하고 지우는 일이 아주 쉬워진다.

		2. 성능적 측면 : 파티셔닝 하지 않은 테이블들이 대용량일 때 인덱스를 이용해서 data를 검색하더라도
				 data의 양이 많아서 인덱스를 아용해 건건히 테이블을 엑세스 하는 방식은
				 일정량이 넘는 순간 full table scan 보다 더 못한 결과가 나온다.
				 그렇다고 full table scan을 해도 부담스럽다면 바로 그때 파티션을 나누면
				 full table scan을 하더라도 일부 파티션 세그먼트만 읽고 멈출 수 있다.

★ 파티션 뷰 생성 


문제 82. 아래의 수동 파티셔닝을 파티션 뷰로 구현하시오 !

========
@demobld
========

	1. 파티션 뷰를 정의할 때 사용할 base 테이블을 만든다.
		create table p1 as select * from emp where deptno = 10;
		create table p2 as select * from emp where deptno = 20;
		create table p3 as select * from emp where deptno = 30;

	2. 체크제약을 반드시 설정해야 함
		alter table p1 add constraint c_deptno_10 check(deptno <20);
		alter table p2 add constraint c_deptno_20 check(deptno>=20 and deptno<30);
		alter table p3 add constraint c_deptno_30 check(deptno>=30);

	3. 인덱스를 생성한다.
		create index p1_empno_idx on p1(empno);
		create index p2_empno_idx on p2(empno);
		create index p3_empno_idx on p3(empno);

	4. 3개의 테이블에 대하여 분석작업을 한다
		analyze table p1 compute statistics;
		analyze table p2 compute statistics;
		analyze table p3 compute statistics;




문제 83. p2 테이블에 아래의 data를 입력하시오 !

	empno  : 3829
	ename  : jack
	sal    : 4000
	deptno : 30

	insert into p2(empno, ename, sal, deptno)
	  values (3829, 'jack', 4000, 30);

		ORA-02290: check constraint (HEAVEN.C_DEPTNO_20) violated

	※ 설명 : p1 테이블에는 부서번호 10번만 입력할 수 있고
		  p2 테이블에는 부서번호 20번만 입력할 수 있고
		  p3 테이블에는 부서번호 30번만 입력할 수 있다.

문제 84. 위에서 준비된 3개의 테이블(segment)을 이용해서 파티션 view를 생성하시오 !

	create or replace view emp_partition
	as
	  select * from p1
	  union all
	  select * from p2
	  union all
	  select * from p3;

	select * from emp_partition;


문제 85. 부서번호 20번인 사원들의 모든 컬럼을 출력하는 아래의 2개의 SQL의 성능을 비교해 보시오 !
	(block의 갯수)

	1. select *
	     from emp_partition
	     where deptno = 20;

	경   과: 00:00:00.03
	--------------------------------------------------------------------------------------
	| Id  | Operation            | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
	--------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT     |               |     5 |   170 |     3   (0)| 00:00:01 |
	|   1 |  VIEW                | EMP_PARTITION |     5 |   170 |     3   (0)| 00:00:01 |
	|   2 |   UNION-ALL          |               |       |       |            |          |
	|*  3 |    FILTER            |               |       |       |            |          |
	|*  4 |     TABLE ACCESS FULL| P1            |     1 |    31 |     2   (0)| 00:00:01 |
	|*  5 |    TABLE ACCESS FULL | P2            |     5 |   155 |     2   (0)| 00:00:01 |
	|*  6 |    FILTER            |               |       |       |            |          |
	|*  7 |     TABLE ACCESS FULL| P3            |     1 |    34 |     2   (0)| 00:00:01 |
	--------------------------------------------------------------------------------------
	          0  db block gets
	          3  consistent gets
	          0  physical reads

	2. select *
	     from emp
	     where deptno = 20;

	경   과: 00:00:00.03
	--------------------------------------------------------------------------
	| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	--------------------------------------------------------------------------
	|   0 | SELECT STATEMENT  |      |     5 |   435 |     2   (0)| 00:00:01 |
	|*  1 |  TABLE ACCESS FULL| EMP  |     5 |   435 |     2   (0)| 00:00:01 |
	--------------------------------------------------------------------------
	          0  db block gets
	          4  consistent gets
	          0  physical reads


★ 파티션 테이블 생성

문제 86. 이번에는 파티션 뷰 말고 실제로 파티션 테이블을 생성하시오 !

	create table emp_partition2
	  partition by range(deptno)			/* 부서번호별로 파티션 하겠다 */
	  (
	    partition p1 values less than (20),		/* 부서번호 10번의 데이터를 구성하겠다. */
	    partition p2 values less than (30),		/* 부서번호 20번의 데이터를 구성하겠다. */
	    partition p3 values less than (40)		/* 부서번호 30번의 데이터를 구성하겠다. */
	  )
	as
	select * from emp;				/* 파티션 하고 싶은 테이블 */

	select * from emp_partition2;	  


	* 아래의 2개의 SQL의 block의 갯수의 차이가 있는지 확인하시오 !

	select * from emp_partition2 where deptno = 20;
	경   과: 00:00:00.03
	-------------------------------------------------
	| Id  | Operation              | Name           |
	-------------------------------------------------
	|   0 | SELECT STATEMENT       |                |
	|   1 |  PARTITION RANGE SINGLE|                |
	|*  2 |   TABLE ACCESS FULL    | EMP_PARTITION2 |
	-------------------------------------------------
	          0  db block gets
	          4  consistent gets
	          0  physical reads

	select * from emp where deptno = 20;

	경   과: 00:00:00.03
	---------------------------------
	| Id  | Operation         | Name
	---------------------------------
	|   0 | SELECT STATEMENT  |
	|*  1 |  TABLE ACCESS FULL| EMP
	---------------------------------
	          0  db block gets
	          8  consistent gets
	          0  physical reads



문제 87. 우리반 테이블을 12c database에 구현하시오 !

	12c database(orcl)  ----------------> 11g database(xe)

	create public database link link_11g
	  connect to heaven
	  identified by heaven
	  using 'localhost:1521/xe';

	select * from tab@link_11g;

	create table emp2
	as
	select * from emp2@link_11g;


문제 88. 우리반 테이블로 range 파티션 테이블을 생성하시오 !

	create table emp2_partition
	  partition by range(age)
	  (
	    partition p1 values less than (27),
	    partition p2 values less than (29),
	    partition p3 values less than (31),
	    partition p4 values less than (45)
	  )
	as
	select * from emp2;


문제 89. 나이가 26살인 학생들의 이름과 나이를 출력하는데 하나는 파티션테이블에서 조회하고 하나는 우리반 테이블에서 조회해서 성능상의 차이가 생기는지 확인하시오 !

	1. 파티션 테이블
		select ename, age
		  from emp2_partition
		  where age = 26;

	경   과: 00:00:00.05
	-------------------------------------------------
	| Id  | Operation              | Name           |
	-------------------------------------------------
	|   0 | SELECT STATEMENT       |                |
	|   1 |  PARTITION RANGE SINGLE|                |
	|*  2 |   TABLE ACCESS FULL    | EMP2_PARTITION |
	-------------------------------------------------
	          0  db block gets
	          4  consistent gets
	          0  physical reads

	2. 우리반테이블
		select ename, age
		  from emp2
		  where age = 26;

	경   과: 00:00:00.04
	----------------------------------
	| Id  | Operation         | Name |
	----------------------------------
	|   0 | SELECT STATEMENT  |      |
	|*  1 |  TABLE ACCESS FULL| EMP2 |
	----------------------------------
	          0  db block gets
	          4  consistent gets
	          0  physical reads

	※ 중요한 점! 파티션 테이블의 효과를 보려면 파티션마다 데이터가 골고루 잘 분포가 되어 있어야 한다.

	* emp2_partition 테이블에 대해서 분석작업을 수행

		exec dbms_stats.gather_table_stats('SCOTT', 'EMP2_PARTITION');

		select table_name, partition_name, num_rows
		  from user_tab_partitions
		  where table_name = 'EMP2_PARTITION';

	TABLE_NAME 		PARTITION_NAME    NUM_ROWS
	----------------------- --------------- ----------
	EMP2_PARTITION 		P4			 5
	EMP2_PARTITION 		P3			 1
	EMP2_PARTITION 		P2			10
	EMP2_PARTITION 		P1			11

	※ 파티션의 종류

		1. range 파티션 ----> 날짜 컬럼이나 숫자 컬럼을 기준으로 나눈 파티션 테이블 (범위를 지정 가능)
			예 : sk텔레콤의 요금테이블의 월별 파티션
	
		2. hash 파티션 -----> 해쉬함수를 이용해서 오라클이 알아서 data를 정해진 파티션 갯수만큼 골고루 분배하는 파티션
	
			장점 : 파티션 테이블을 생성하기 편하다. 
			단점 : 어느데이터가 어느 파티션에 들어가 있는지 알기 어렵다
	
		3. list 파티션 -----> 사용자에 의해 미리 정해진 그룹핑 기준에 따라 데이터를 분할하는 파티셔
	
			예 : 우리반 테이블을 통신사 별로 파티셔닝 하고 싶다.
				sk, kt, lg
	
		4. 복합 파티션
			range - hash  파티션
			range - list  파티션
			range - range 파티션
			list  - hash  파티션
			list  - list  파티션
			list  - range 파티션 



	※ hash 파티션 생성 방법

		create table emp195
		partition by hash(deptno) partitions 3
		as
		  select * from emp;

		exec dbms_stats.gather_table_stats('SCOTT', 'EMP195');

		select table_name, partition_name, num_rows
		  from user_tab_partitions
		  where table_name = 'EMP195';

	TABLE_NAME	PARTITION_NAME	 NUM_ROWS
	--------------- ---------------- --------
	EMP195		SYS_P286 		6
	EMP195		SYS_P287 		3
	EMP195		SYS_P288 		5



문제 90. 우리반 테이블을 해쉬 파티션으로 생성하시오 ( 파티션 테이블 이름 : emp2_hash_partition )

	create table emp2_hash_partition
	partition by hash(age) partitions 3
	as
	select * from emp2;

		exec dbms_stats.gather_table_stats('SCOTT', 'EMP2_HASH_PARTITION');

		select table_name, partition_name, num_rows
		  from user_tab_partitions
		  where table_name = 'EMP2_HASH_PARTITION';

		TABLE_NAME		PARTITION_NAME		  NUM_ROWS
		----------------------- ------------------------- --------
		EMP2_HASH_PARTITION	SYS_P289			9
		EMP2_HASH_PARTITION	SYS_P290			15
		EMP2_HASH_PARTITION	SYS_P291			3


문제 91. 사원 테이블의 부서번호로 list 파티션을 생성하시오 !

	create table emp_list_partition
	partition by list(deptno)
	(
	  partition p1 values ('10'),
	  partition p2 values ('20'),
	  partition p3 values ('30')
	)
	as
	select * from emp;

		exec dbms_stats.gather_table_stats('SCOTT', 'EMP_LIST_PARTITION');

		select table_name, partition_name, num_rows
		  from user_tab_partitions
		  where table_name = 'EMP_LIST_PARTITION';

		TABLE_NAME		PARTITION_NAME 	 NUM_ROWS
		----------------------- ---------------- --------
		EMP_LIST_PARTITION	P1			3
		EMP_LIST_PARTITION	P2			5
		EMP_LIST_PARTITION	P3			6



문제 92. 우리반 테이블을 통신사별로 나눠서 리스트 파티션 테이블을 생성하시오 ! (점심시간 문제)
		(골고루 데이터가 분배되었는지 보여주세요 ! )

	create table emp2_list_partition
	partition by list(telecom)
	(
	  partition p1 values ('sk'),
	  partition p2 values ('lg'),
	  partition p3 values ('kt')
	)
	as
	select * from emp2 e;

		exec dbms_stats.gather_table_stats('SCOTT', 'EMP2_LIST_PARTITION');

		select table_name, partition_name, num_rows
		  from user_tab_partitions
		  where table_name = 'EMP2_LIST_PARTITION';

		TABLE_NAME		PARTITION_NAME		  NUM_ROWS
		----------------------- ------------------------- --------
		EMP2_LIST_PARTITION	P1				13
		EMP2_LIST_PARTITION	P2				 5
		EMP2_LIST_PARTITION	P3				 9


★ 파티션 pruning

	prune 의 뜻 ? 쓸대 없는 가지를 치다
		      불필요한 부분을 제거한다.

	SQL을 실행하는 시점에서 SQL의 조건절을 분석해서 읽지 않아도 되는 파티션 세그먼트를 엑세스
	대상에서 제외시키는 기능

	* 파티션 프루닝이 되고 있는 실행계획

	  select *
	    from emp_partition2
	    where deptno = 20;

		경   과: 00:00:00.01
		-------------------------------------------------
		| Id  | Operation              | Name           |
		-------------------------------------------------
		|   0 | SELECT STATEMENT       |                |
		|   1 |  PARTITION RANGE SINGLE|                |
		|*  2 |   TABLE ACCESS FULL    | EMP_PARTITION2 |
		-------------------------------------------------
		          0  db block gets
		          4  consistent gets
		          0  physical reads

		※ PARTITION RANGE SINGLE --------> 파티션 프루닝이 되고 있다.
						    즉 옷장의 해당 서랍만 열었다.


문제 93. 점심시간 문제로 만들었던 통신사별로 구분한 파티션 테이블의 쿼리문을 작성해서 파티션 프루닝을
	 하는지 확인하시오 !

	select *
	  from emp2_list_partition
	  where telecom = 'sk';

		경   과: 00:00:00.09
		-----------------------------------------------------
		| Id  | Operation             | Name                |
		-----------------------------------------------------
		|   0 | SELECT STATEMENT      |                     |
		|   1 |  PARTITION LIST SINGLE|                     |
		|   2 |   TABLE ACCESS FULL   | EMP2_LIST_PARTITION |
		-----------------------------------------------------
		          0  db block gets
		          4  consistent gets
		          0  physical reads



☆ 실행계획 보는 방법 2가지

	1. 예상 실행계획 보는 방법 ---> SQL gate 에서 F7 누르면 된다.

	2. 실제 실행계획 보는 방법 ---> 실제로 실행을 하면서 실행할때 사용한 수행계획 확인


	ed p.sql

	select *
	from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST +alias +outline +predicate'));

	select /*+ gather_plan_statistics */ *
	  from emp_partition2
	  where deptno = 20;

	@p

     ---------------------------------------------------------------------------------------------------
     | Id  | Operation              | Name           | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
     ---------------------------------------------------------------------------------------------------
     |   0 | SELECT STATEMENT       |                |      1 |        |      5 |00:00:00.01 |       4 |
     |   1 |  PARTITION RANGE SINGLE|                |      1 |      5 |      5 |00:00:00.01 |       4 |
     |*  2 |   TABLE ACCESS FULL    | EMP_PARTITION2 |      1 |      5 |      5 |00:00:00.01 |       4 |
     ---------------------------------------------------------------------------------------------------
	※ 버퍼가 우리가 항상 보던 블락 수를 의미한다 그래서 이것을 보고 버퍼가 크면 병목부분이라고
	   하고 이곳을 중심으로 튜닝을 진행한다.


	

☆ 파티션 프루닝이 안되는 경우

	1. where 절의 조건 컬럼을 가공했을 때

	select /*+ gather_plan_statistics */ *
	  from emp_partition2
	  where trim(deptno) = 20;

	------------------------------------------------------------------------------------------------
	| Id  | Operation           | Name           | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
	------------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT    |                |      1 |        |      5 |00:00:00.01 |      10 |
	|   1 |  PARTITION RANGE ALL|                |      1 |      1 |      5 |00:00:00.01 |      10 |
	|*  2 |   TABLE ACCESS FULL | EMP_PARTITION2 |      3 |      1 |      5 |00:00:00.01 |      10 |
	------------------------------------------------------------------------------------------------


	2. 등차조건이나 in 조건이 아닐 때 (hash 파티션일때만)

	select /*+ gather_plan_statistics */ *
	  from emp195			/* hash 파티션 */
	  where deptno like '2%';

	---------------------------------------------------------------------------------------
	| Id  | Operation          | Name   | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
	---------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |        |      1 |        |      5 |00:00:00.01 |      10 |
	|   1 |  PARTITION HASH ALL|        |      1 |      1 |      5 |00:00:00.01 |      10 |
	|*  2 |   TABLE ACCESS FULL| EMP195 |      3 |      1 |      5 |00:00:00.01 |      10 |
	---------------------------------------------------------------------------------------







★ 파티션 와이즈 조인 (wise join)
		"파티션끼리 조인 하는 것"

				10	20	30	40
	emp_partition		□	□	□	□

				↓	↓	↓	↓   ----> 파티션 끼리 조인

	dept_partition		□	□	□	□



	* 파티션 와이즈 조인이 아닌 경우

	emp	10	20	10	20	30	10	20	20	.......
		→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→
		↑
	
	dept	10	20	30	40


=========================
drop view emp_partition;
drop table emp_partition;
=========================


문제 94. emp_partition 파티션 테이블과 dept_partition 파티션 테이블을 deptno를 파티션 키로 해서
	 생성하시오 !

	create table emp_partition
	partition by range(deptno)
	(
	  partition p1 values less than (20),
	  partition p2 values less than (30),
	  partition p3 values less than (40),
	  partition p4 values less than (50)
	)
	as
	select * from emp;

	create table dept_partition
	partition by range(deptno)
	(
	  partition p1 values less than (20),
	  partition p2 values less than (30),
	  partition p3 values less than (40),
	  partition p4 values less than (50)
	)
	as
	select * from dept;

		select * from emp_partition;
		select * from dept_partition;



문제 95. emp_partition과 dept_partition을 조인해서 이름과 부서위치와 부서번호를 출력하고 실행계획을
	 확인하시오 !

	select /* gather_plan_statistics */ e.ename, d.loc, e.deptno
	  from emp_partition e, dept_partition d
	  where e.deptno = d.deptno;

	-------------------------------------------------------------
	| Id  | Operation                 | Name           | E-Rows |
	-------------------------------------------------------------
	|   0 | SELECT STATEMENT          |                |        |
	|   1 |  NESTED LOOPS             |                |     14 |
	|   2 |   PARTITION RANGE ALL     |                |      4 |
	|   3 |    TABLE ACCESS FULL      | DEPT_PARTITION |      4 |
	|   4 |   PARTITION RANGE ITERATOR|                |      4 |
	|*  5 |    TABLE ACCESS FULL      | EMP_PARTITION  |      4 |
	-------------------------------------------------------------
		※ 해쉬조인으로 유도를 해야 파티션 와이즈조인을 한다.


문제 96. 위의 조인문을 해쉬조인으로 유도해서 파티션 와이즈 조인이 되게 하시오 !

	select /*+ leading(d e) use_hash(e) full(d) full(e) 
		  parallel(e 2) parallel(d 2) 
		  pq_distribute(e,none,none) */ 
		e.ename, d.loc, e.deptno
	  from emp_partition e, dept_partition d
	  where e.deptno = d.deptno;
		---------------------------------------------------
		| Id  | Operation                | Name           |
		---------------------------------------------------
		|   0 | SELECT STATEMENT         |                |
		|   1 |  PX COORDINATOR          |                |
		|   2 |   PX SEND QC (RANDOM)    | :TQ10000       |
		|   3 |    PX PARTITION RANGE ALL|                |
		|*  4 |     HASH JOIN            |                |
		|   5 |      TABLE ACCESS FULL   | DEPT_PARTITION |
		|   6 |      TABLE ACCESS FULL   | EMP_PARTITION  |
		---------------------------------------------------
		※ 조인하려는 테이블이 둘다 파티션 테이블인데 파티션 와이즈 조인을 안한다면
		   pq_distribute(e,none,none)를 사용해야 한다. (e 는 해쉬의 디스크 테이블)


☆ 둘다 파티션 테이블이 아닌 경우 (동적 파티셔닝)
		---------------------------->
	조인 : outer table 	:	 inner table
		( dept )		   ( emp )

		파티션 x		  파티션 x
		big table		  big table

	힌트 : pq_distribute ( emp, hash, hash )
		테이블을 둘다 파티셔닝 하고 full partition wise 조인 해라 ~

		그럼 파티션 테이블을 안만들면 되겠네~
		놉 ! 이것은 파티션 만들 때 메모리를 많이 써서 좋은 방법은 아니다.


	select /*+ leading(d e) use_hash(e) full(d) full(e) 
		  parallel(e 2) parallel(d 2) 
		  pq_distribute(e, hash, hash) */ 
		e.ename, d.loc, e.deptno
	  from emp e, dept d
	  where e.deptno = d.deptno;

	-----------------------------------------------
	| Id  | Operation                  | Name     |
	-----------------------------------------------
	|   0 | SELECT STATEMENT           |          |
	|   1 |  PX COORDINATOR            |          |
	|   2 |   PX SEND QC (RANDOM)      | :TQ10002 |
	|*  3 |    HASH JOIN BUFFERED      |          |
	|   4 |     PX RECEIVE             |          |
	|   5 |      PX SEND HYBRID HASH   | :TQ10000 |
	|   6 |       STATISTICS COLLECTOR |          |
	|   7 |        PX BLOCK ITERATOR   |          |
	|   8 |         TABLE ACCESS FULL  | DEPT     |
	|   9 |     PX RECEIVE             |          |
	|  10 |	     PX SEND HYBRID HASH   | :TQ10001 |
	|  11 |       PX BLOCK ITERATOR    |          |
	|  12 |        TABLE ACCESS FULL   | EMP      |
	-----------------------------------------------
	※ 연결고리를 기준으로 파티션을 나눈다. 그리고 대용량이 되면 그냥 조인하는것 보다는
	   확실히 빠르기 때문에 파티션 와이즈 조인을 쓰는 것이다!


=====================================
create table telecom_price
as
select * from telecom_price@link_11g;
=====================================


문제 97. 우리반 (emp2) 테이블과 telecom_price테이블을 조인해서 이름과 나이와 텔레콤과 month_price
	 를 출력하는데 파티션 와이즈 조인이 되게 하시오 !

	select/*+ gather_plan_statistics
		  leading(t e) use_hash(e) full(t) full(e)
		  parallel(t 2) parallel(e 2)
		  pq_distribute(e, hash, hash) */ 
		  e.ename, e.age, e.telecom, t.month_price
	  from emp2 e, telecom_price t
	  where e.telecom = t.telecom_name;

	----------------------------------------------------
	| Id  | Operation                  | Name          |
	----------------------------------------------------
	|   0 | SELECT STATEMENT           |               |
	|   1 |  PX COORDINATOR            |               |
	|   2 |   PX SEND QC (RANDOM)      | :TQ10002      |
	|*  3 |    HASH JOIN BUFFERED      |               |
	|   4 |     PX RECEIVE             |               |
	|   5 |      PX SEND HYBRID HASH   | :TQ10000      |
	|   6 |       STATISTICS COLLECTOR |               |
	|   7 |        PX BLOCK ITERATOR   |               |
	|*  8 |         TABLE ACCESS FULL  | TELECOM_PRICE |
	|   9 |     PX RECEIVE             |               |
	|  10 |      PX SEND HYBRID HASH   | :TQ10001      |
	|  11 |       PX BLOCK ITERATOR    |               |
	|* 12 |        TABLE ACCESS FULL   | EMP2          |
	----------------------------------------------------
		※ 파티셔닝을 해주는 힌트를 쓰려면 병렬 힌트도 꼭 같이 써야한다
		   왜냐하면 병렬처리 때문에 나누는 부분에 파티션한 조각들이 들어가기 때문이다.
		   그래서 병렬을 같이 붙이는데 병렬 개수는 파티션을 할 수 있게 짝수로만 써주는게 좋다.






★ 인덱스 파티셔닝

	"인덱스의 크기가 너무 커서 인덱스를 파티션해서 성능을 높이겠다."

	* 인덱스 파티션의 종류

		1. 로컬 파티션 인덱스
			"파티션 테이블의 파티션에 각각 로컬 인덱스로 구성된 인덱스"

		2. 비 파티션 인덱스
			"테이블은 파티션 되어져 있는데 인덱스는 파티셔닝 되지 않은 인덱스"

		3. 글로벌 파티션 인덱스
			"테이블도 파티션 되어져 있고 인덱스도 파티션 되어있는데 테이블 파티션과 인덱스
			 파티션과의 관계가 서로 독립적 구조로 되어있는 인덱스 "

	※ 파티션 인덱스 이미지 참고!

	※ 각자 장단점이 있다. 로컬이 가장 쓰기 편해보이지만 단점은 저장공간을 많이 차지한다.
	   


문제 98. emp_partition 테이블의 deptno에 로컬 파티션 인덱스를 생성하시오 !

	create index emp_partition_local
	  on emp_partition(deptno) local;

	select bytes, blocks
	  from user_segments
	  where segment_name = 'EMP_PARTITION_LOCAL';

		     BYTES     BLOCKS
		---------- ----------
		   8454144       1032
		   8454144       1032
		   8454144       1032


 * 로컬 파티션 인덱스

	1. prefixed 파티션 인덱스 : deptno +job
				      ↑
				파티션 키 컬럼

		drop index emp_partition_index;

		create index emp_partition_index
		  on emp_partition(deptno, job) local;

			※파티션 키 컬럼이 선두에 있는 결합 컬럼 인덱스가 prefixed

	2. non prefixed 파티션 인덱스 : job + deptno
						↑
					   파티션 키 컬럼

		drop index emp_partition_index

		create index emp_partition_index
		  on emp_partition(job, deptno) local;

		테이블은 deptno를 기준으로 파티션 되어있는데 SQL에 where 절에 주로 job을 검색한다고 하면 
		non partition index가 필요하다.



 * 비 파티션 인덱스 

	drop index emp_partition_local;

	create index emp_partition_index
	  on emp_partition(deptno) ;


	※ 로컬 파티션 인덱스와 비 파티션 인덱스의 장단점

		- 로컬 파티션 인덱스 : 장점 - 관리가 쉽다. 검색 성능이 좋다
				       단점 - 공간을 많이 사용한다.

		- 비 파티션 인덱스 : 장점 - 공간을 적게 사용한다.
				     단점 - 관리가 불편하다.

	* 어떤점이 불편한가?
		비 파티션 인덱스에 관련된 파티션 테이블을 drop했을 때 비 파티션 인덱스가 invalid 되어서
		인덱스를 rebuild 해줘야 한다.

		alter table emp_partition
		  drop partition p1;

		select index_name, status
		  from user_indexes
		  where index_name = 'EMP_PARTITION_INDEX';

			INDEX_NAME		STATUS
			----------------------- --------
			EMP_PARTITION_INDEX	UNUSABLE
	
			※ 이렇게 되어버리면 이 인덱스는 못쓴다.

				select /*+ index(e emp_partition_index) */ ename, sal
				  from emp_partition e
				  where deptno = 20;

				ORA-01502: 인덱스 'SCOTT.EMP_PARTITION_INDEX'또는 
					   인덱스 분할영역은 사용할 수 없은 상태입니다

		그래서 rebuild를 해줘야 한다.
			※대용량이라면 엄청 오래 걸린다.

			alter index emp_partition_index rebuild;
	
			select /*+ index(e emp_partition_index) */ ename, sal
			  from emp_partition e
			  where deptno = 20;

			ENAME             SAL
			---------- ----------
			JONES            2975
			FORD             3000
			SMITH             800	
			SCOTT            3000
			ADAMS            1100





■ 병렬처리가 무엇인가?

	"SQL문이 수행해야 할 작업 범위를 여러개의 작은 단위로 나누어 여러 프로세서가 동시에 처리하는 
	 것을 말한다."


 * 병렬 처리
	1. 하나의 서버 내에서의 병렬처리 ----> 오라클
	2. 2 ~4대의 서버 에서의 병렬처리 ----> 오라클 RAC
	3. 여러대의 서버에서 각각 병렬처리 --> 하둡

		하둡을 이용하게 되면 분산 컴퓨팅 방식을 사용해서 기존 데이터 븐석방식으로는 상상도 
		못했던 성과를 보여준다.

		예 : 2008년 뉴욕 타임즈 130년 분량의 신문기사 1100만 페이지를 아마존 하둡을 이용해서
		     하루만에 PDF로 변환하는데 성공했다. 이때 소요된 비용이 200만원에 불과했다.
		     하둡을 이용하지 않으면 14년이 소요되는 엄청난 작업량이었다.




★ 병렬 DML 작업

	* insert 문의 성능을 높이기 위한 방법
	  (High Water Mark : 위로 data를 입력하는 명령어)

		      [emp]
	□□□□□□□□□□□□□□□□□
	□□□□□□□□□□□□□□□□□
	---------------------------------------------> high water mark
 	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■-----------> data
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
	■■■■■■■■■■■■■■■■■
		※ 항상 풀스캔을 하면 high water mark 까지 스캔을 한다.
		   insert를 하면 high water mark 밑에 빈공간을 찾아서 insert가 이루어 진다.
	여기서 high water mark 위로 데이터를 입력하는 명령어가 있는데 그렇게 한다면 
	빈공간을 찾을 필요가 없기 때문에 입력 속도가 빨라진다.

	create table emp302
	as
	select *		/* 테이블 구조 생성 */
	  from emp
	  where 1=2;

	insert into emp302	/* 테이블 값 입력 */
	select * from emp;

	select * from emp302;

	delete from emp302;	/* 듬성듬성 지워야 하는데 그냥 전부 지웠다. */
				/* high water mark의 높이는 그대로 */
	commit;

	※ high water mark 는 truncate를 해야 높이가 내려간다.


	* high water mark 위로 데이터를 입력하는 방법 
	
	1. append 힌트 : high water mark 위로 데이터를 입력하겠다.

		insert /*+ append */ into emp302
		  select * from emp;
	
		select * from emp302;
	
			ORA-12838: 병렬로 수정한 후 객체를 읽거나 수정할 수 없습니다r
				※ high water mark 위로 데이터를 넣었기 때문에 commit을 해야 
				   high water mark의 높이가 넣은데이터 위로 올라가서 검색이 가능하다.
		
		☆ 저장공간 낭비가 생기지만 빨리 insert 할 수 있다.

	2. parallel 힌트 : high water mark 위로 데이터를 입력하는데 병렬로 입력하겠다.

		delete from emp302;
		commit;

		alter session enable parallel dml;		/* 이 명령어를 날려줘야 병렬 insert 가능
								*/

		insert /*+ parallel(e3 4) */ into emp302 e3
		select * from emp;

		commit;

		select * from emp302;

		
문제 99. sales 테이블의 데이터를 sales 테이블의 구조만 가지고 있는 sales 500 테이블에 입력할 때 
	 병렬로 입력했을 때와 병렬이 아닌 serial로 입력했을 때와 속도 차이를 확인하시오 !

	create table sales		|	set timing on
	as				|	
	select * from sh.sales;		|	insert into sales500
					|	select * from sales;
	select count(*) from sales;	|	
					|	918843 행이 생성되었습니다.
	create table sales500		|	경   과: 00:00:02.26
	as				|	
	select * from sales		|	truncate table sales500;
	  where 1=2;			|	
					|
					|	alter session enable parallel dml;
					|
					|	insert /* parallel(s5 4) */ into sales500 s5
					|	select * from sales;
					|
					|	918843 행이 생성되었습니다.
					|	경   과: 00:00:01.18
