
★index 엑세스 방법

	1. index range scan          	중요!
	2. index unique scan
	3. index full scan
	4. index fast full scan		중요!
	5. index skip scan		중요!
	6. index merge scan
	7. index bitmap merge scan










★ index unique scan
	 " unique 한 인덱스를 엑세스하는 스캔 방법"

 * 인덱스의 종류 2가지

	1. unique 인덱스 : 인덱스를 걸 컬럼의 데이터가 unique한 데이터인 경우

		예 : empno ( 사원번호 )

	2. non unique 인덱스 : 인덱스를 걸 컬럼의 데이터가 중복되어 있는 경우의 생성될 인덱스

 * unique 인덱스 생성 방법 2가지 

	1. 명시적 방법 : 
			create unique index emp_empno
			  on emp(empno);

	2. 암시적 방법 : primary key와 unique 제약을 걸면 자동으로 unique 인덱스가 생성된다. 

 * 테스트 

	1. demobld.sql 스크립트를 수행하시오

	2. create unique index emp_empno
	     on emp(empno);

	   create index emp_sal
	     on emp(sal);

	3. select index_name, uniqueness
	     from user_indexes
	     where table_name = 'EMP';

		=======================================================================
		INDEX_NAME                                                   UNIQUENESS
		------------------------------------------------------------ ----------
		EMP_EMPNO                                                    UNIQUE
		EMP_SAL                                                      NONUNIQUE
		=======================================================================

	4. 다시 demobld스크립트를 돌린다.

	5. insert into emp (empno, ename, sal)
	     values ( 7788, 'SCOTT', 3000);

	6. create unique index emp_empno
	     on emp(empno);

		ORA-01452: cannot CREATE UNIQUE INDEX; duplicate keys found
		※ 설명 : 중복된 데이터가 있으면 unique인덱스가 안걸린다.
			  다시 말하면 unique index가 걸리는 컬럼은 그 컬럼에 중복된 데이터가
			  하나도 없다는 것이다.


문제 25. demobld 스크립트를 다시 돌리고 사원 테이블의 empno에 primary key제약을 걸고 unique 인덱스가
	 자동으로 생성되었는지 확인하시오 !

	@demobld

	alter table emp
	  add constraint emp_empno_pk primary key(empno);

	select index_name, uniqueness
	  from user_indexes
	  where table_name = 'EMP';

		=======================================================================
		INDEX_NAME                                                   UNIQUENESS
		------------------------------------------------------------ ----------
		EMP_EMPNO_PK                                                 UNIQUE
		=======================================================================


문제 26. 위의 상황에서 이름에 non unique index를 걸고 아래의 SQL을 수행하면 어느 컬럼의 인덱스를 사용할
	 것인가 ?

	create index emp_ename
	  on emp(ename);

	select empno, ename, sal, job
	  from emp
	  where empno = 7788 and ename = 'SCOTT';
		 ↑		   ↑
		인덱스		 인덱스
		==================================================
		     EMPNO ENAME                       SAL JOB
		---------- -------------------- ---------- -------
		      7788 SCOTT                      3000 ANALYST
		==================================================
		----------------------------------------------------
		| Id  | Operation                   | Name         |
		----------------------------------------------------
		|   0 | SELECT STATEMENT            |              |
		|*  1 |  TABLE ACCESS BY INDEX ROWID| EMP          |
		|*  2 |   INDEX UNIQUE SCAN         | EMP_EMPNO_PK |
		----------------------------------------------------
		==================
		0  db block gets
		2  consistent gets
		0  physical reads
		==================
	 * 오라클이 우선순위를 non unique 인덱스보다 unique인덱스를 훨씬 높게 준다.

	 * 오라클 우선순위 표

		1. rowid에 의한 데이터 엑세스
		
			:
		10. full table scan


문제 27. 우리반 테이블의 이름에 unique 제약을 걸고 unique 인덱스가 생성되었는지 확인하시오 !
	@demobld

	alter table emp
	  add constraint emp_ename_un unique(ename);

	select index_name, uniqueness
	  from user_indexes
	  where table_name = 'EMP';

		===============================================================================
		INDEX_NAME                                                   UNIQUENESS
		------------------------------------------------------------ ------------------
		EMP_ENAME_UN                                                 UNIQUE
		===============================================================================


문제 28. 사원번호가 7788번인 사원의 사원번호와 이름과 월급을 출력하는 SQL의 실행계획을 보고
	 index unique scan 했는지 확인하시오 !

	select empno, ename, sal
	  from emp
	  where empno = 7788;

		====================================================
		----------------------------------------------------
		| Id  | Operation                   | Name         |
		----------------------------------------------------
		|   0 | SELECT STATEMENT            |              |
		|   1 |  TABLE ACCESS BY INDEX ROWID| EMP          |
		|*  2 |   INDEX UNIQUE SCAN         | EMP_EMPNO_PK |
		----------------------------------------------------
		====================================================

			    인덱스
		---------- ------------------
		      7369 AAAFADAABAAALCxAAK
		      7499 AAAFADAABAAALCxAAF
		      7521 AAAFADAABAAALCxAAI
		      7566 AAAFADAABAAALCxAAD
		      7654 AAAFADAABAAALCxAAE
		      7698 AAAFADAABAAALCxAAB
		      7782 AAAFADAABAAALCxAAC
		   [  7788 AAAFADAABAAALCxAAL ]  <----- INDEX UNIQUE SCAN 은 딱 한건만 읽는다!
		      7839 AAAFADAABAAALCxAAA
		      7844 AAAFADAABAAALCxAAG
		      7876 AAAFADAABAAALCxAAM
		      7900 AAAFADAABAAALCxAAH
		      7902 AAAFADAABAAALCxAAJ
		      7934 AAAFADAABAAALCxAAN












★index merge scan

	"데이터를 검색할 때 두개의 인덱스를 동시에 사용해서 더 큰 시너지 효과를 보는 스캔 방법"

 * 테스트 : 
	create index emp_job on emp(job);
	create index emp_deptno on emp(deptno);

	select empno, ename, job, deptno
	  from emp
	  where job = 'SALESMAN' and deptno = 30;

	실행계획을 확인하시오 !
		-----------------------------------------------
		| Id  | Operation                   | Name    |
		-----------------------------------------------
		|   0 | SELECT STATEMENT            |         |
		|*  1 |  TABLE ACCESS BY INDEX ROWID| EMP     |
		|*  2 |   INDEX RANGE SCAN          | EMP_JOB |
		-----------------------------------------------
		==================
		0  db block gets
		4  consistent gets
		0  physical reads
		==================
				   job  		deptno
				  COUNT(*)		  COUNT(*)
				----------		----------
				         4		         6
			※ job이 더 간단하기 때문에 옵티마이져가 job을 이용했다.


	실행계획을 보니 job의 인덱스를 탔는데 만약 두개의 인덱스를 동시에 사용하고 싶다면?

	select /*+ and_equal(emp emp_deptno emp_job) */ empno, ename, job, deptno
	  from emp
	  where job = 'SALESMAN' and deptno = 30;

		--------------------------------------------------
		| Id  | Operation                   | Name       |
		--------------------------------------------------
		|   0 | SELECT STATEMENT            |            |
		|*  1 |  TABLE ACCESS BY INDEX ROWID| EMP        |
		|   2 |   AND-EQUAL                 |            |
		|*  3 |    INDEX RANGE SCAN         | EMP_DEPTNO |
		|*  4 |    INDEX RANGE SCAN         | EMP_JOB    |
		--------------------------------------------------
		==================
		0  db block gets
		8  consistent gets
		0  physical reads
		==================

	하지만 요즘에 이것보다 더 강력한 힌트가 있어서 merge scan은 잘 안쓴다.












★ index bitmap merge scan

	" 두개의 인덱스를 사용하는 것은 index merge scan과 똑같은데 다른것은 인덱스를 bit로 변환
	  해서 사이즈를 확 줄인 다음에 스캔한다는 것이 차이점이다."

	예 : 책 앞에 목차가 10장, 책 뒤의 목차도 10장 이라고 하면 index merge scan이 10장, 10장 
	     두개를 같이 읽어서 테이블에 찾아갈 rowid를 알아낸다면
	     index bitmap merge scan은 10장을 1장으로 요약한다. 1장. 1장 두개를 같이 읽어서 테이블에
	     찾아갈 rowid를 알아낸다.

	alter table emp
	  modify job not null;

	alter table emp
	  modify deptno not null;


	select /*+ index_combine(emp emp_job emp_deptno) */ empno, ename, job, deptno
	  from emp
	  where job = 'SALESMAN' and deptno = 30;






문제 29. 아래의 SQL을 튜닝하시오 !

	create index emp2_ename on emp2(ename);

	튜닝전 :
		select ename, age, major
		  from emp2
		  where substr(ename, 1, 1) = '김';
		=======================================
		ENAME	       AGE MAJOR
		------  ---------- -------------------
		김준구		27 보건행정학과
		김준하		27 정보통계보험수리학과
		김건휘		26 통계학과
		김용원		31 컴퓨터과학과
		김혜진		23 마케팅학과
		김진철		33 물리학과
		김용식		32 분자생물학
		=======================================
		----------------------------------
		| Id  | Operation         | Name |
		----------------------------------
		|   0 | SELECT STATEMENT  |      |
		|*  1 |  TABLE ACCESS FULL| EMP2 |
		----------------------------------
		==================
		0  db block gets
		3  consistent gets
		0  physical reads
		==================

	튜닝후 : 
		select /*+ index(emp2 emp2_ename) */ ename, age, major
		  from emp2
		  where ename like '김%';
		=======================================
		ENAME	       AGE MAJOR
		------  ---------- -------------------
		김준구		27 보건행정학과
		김준하		27 정보통계보험수리학과
		김건휘		26 통계학과
		김용원		31 컴퓨터과학과
		김혜진		23 마케팅학과
		김진철		33 물리학과
		김용식		32 분자생물학
		=======================================
		--------------------------------------------------
		| Id  | Operation                   | Name       |
		--------------------------------------------------
		|   0 | SELECT STATEMENT            |            |
		|   1 |  TABLE ACCESS BY INDEX ROWID| EMP2       |
		|*  2 |   INDEX RANGE SCAN          | EMP2_ENAME |
		--------------------------------------------------
		==================
		0  db block gets
		4  consistent gets
		0  physical reads
		==================


문제 30. 아래의 SQL을 튜닝하시오 !

	create index emp2_age on emp2(age);

	튜닝전 : 
		select ename, age, major
		  from emp2
		  where age like '4%';
			숫자  >  문자       문자 --> 숫자 해야하는데 % 때문에 못함
		====================================
		ENAME     	  AGE MAJOR
		---------- ---------- --------------
		허석우    	   40 정보통신공학과
		====================================
		----------------------------------
		| Id  | Operation         | Name |
		----------------------------------
		|   0 | SELECT STATEMENT  |      |
		|*  1 |  TABLE ACCESS FULL| EMP2 |
		----------------------------------
		==================
		0  db block gets
		3  consistent gets
		0  physical reads
		==================

	튜닝후 : 
		create index emp2_age_func on emp2(to_char(age));
		
		select ename, age, major
		  from emp2
		  where age like '4%';
		====================================
		ENAME     	  AGE MAJOR
		---------- ---------- --------------
		허석우    	   40 정보통신공학과
		-----------------------------------------------------
		| Id  | Operation                   | Name          |
		-----------------------------------------------------
		|   0 | SELECT STATEMENT            |               |
		|   1 |  TABLE ACCESS BY INDEX ROWID| EMP2          |
		|*  2 |   INDEX RANGE SCAN          | EMP2_AGE_FUNC |
		-----------------------------------------------------
		==================
		0  db block gets
		2  consistent gets
		0  physical reads
		==================


문제 31. (점심시간 문제) 아래의 sql을 튜닝하시오 !
	전공에 통계가 포함되어져 있는 학생들의 이름과 전공을 출력하시오 !

	create index emp2_major on emp2(major);

	튜닝전 : 
		select ename, major
		  from emp2
		  where major like '%통계%';
		=================================================================================
		ENAME                                                        MAJOR
		------------------------------------------------------------ --------------------
		김준하                                                       정보통계보험수리학과
		김건휘                                                       통계학과
		주소현                                                       통계학과
		이소진                                                       통계학과
		안혜진                                                       통계학과
		=================================================================================
		----------------------------------
		| Id  | Operation         | Name |
		----------------------------------
		|   0 | SELECT STATEMENT  |      |
		|*  1 |  TABLE ACCESS FULL| EMP2 |
		----------------------------------
		==================
		0  db block gets
		3  consistent gets
		0  physical reads
		==================
	
	튜닝후 : 
		select e.ename, e.major
		  from emp2 e, (select /*+ no_merge index_ffs(emp2 emp2_major) */ rowid rn
		                 from emp2
		                 where major like '%통계%') r
		  where e.rowid = r.rn;
		=================================================================================
		ENAME                                                        MAJOR
		------------------------------------------------------------ --------------------
		김준하                                                       정보통계보험수리학과
		김건휘                                                       통계학과
		주소현                                                       통계학과
		이소진                                                       통계학과
		안혜진                                                       통계학과
		=================================================================================
		--------------------------------------------------
		| Id  | Operation                   | Name       |
		--------------------------------------------------
		|   0 | SELECT STATEMENT            |            |
		|   1 |  NESTED LOOPS               |            |
		|   2 |   VIEW                      |            |
		|*  3 |    INDEX FAST FULL SCAN     | EMP2_MAJOR |
		|   4 |   TABLE ACCESS BY USER ROWID| EMP2       |
		--------------------------------------------------
		==================
		0  db block gets
		6  consistent gets
		0  physical reads
		==================


문제 32. 아래의 SQL을 튜닝하시오 !
	튜닝전 : 
		select ename, sal
		  from emp
		  where sal = ( select max(sal) from emp);
		===============================
		ENAME                       SAL
		-------------------- ----------
		KING                       5000
		===============================
		------------------------------------
		| Id  | Operation           | Name |
		------------------------------------
		|   0 | SELECT STATEMENT    |      |
		|*  1 |  TABLE ACCESS FULL  | EMP  |
		|   2 |   SORT AGGREGATE    |      |
		|   3 |    TABLE ACCESS FULL| EMP  |
		------------------------------------
		==================
		0  db block gets
		7  cons	istent gets
		0  physical reads
		==================

	튜닝후 : 
		create index emp_sal
		  on emp( sal );

		select /*+ index_desc(emp emp_sal) */ ename, sal
		  from emp
		  where sal >= 0 and rownum = 1;
		===============================
		ENAME                       SAL
		-------------------- ----------
		KING                       5000
		===============================
		---------------------------------------
		| Id  | Operation                     |
		---------------------------------------
		|   0 | SELECT STATEMENT              |
		|*  1 |  COUNT STOPKEY                |
		|   2 |   TABLE ACCESS BY INDEX ROWID |
		|*  3 |    INDEX RANGE SCAN DESCENDING|
		---------------------------------------
		==================
		0  db block gets
		2  consistent gets
		0  physical reads
		==================


아래의 SQL을 튜닝하시오 !
	튜닝전 : 
		select ename, hiredate
		  from emp
		  where hiredate = (select min(hiredate) from emp);
		=============================
		ENAME                HIREDATE
		-------------------- --------
		SMITH                80/12/09
		=============================
		------------------------------------
		| Id  | Operation           | Name |
		------------------------------------
		|   0 | SELECT STATEMENT    |      |
		|*  1 |  TABLE ACCESS FULL  | EMP  |
		|   2 |   SORT AGGREGATE    |      |
		|   3 |    TABLE ACCESS FULL| EMP  |
		------------------------------------
		==================
		0  db block gets
		7  consistent gets
		0  physical reads
		==================
	
	튜닝후 :
		create index emp_hiredate
		  on emp(hiredate);

		select /*+ index_asc(emp emp_hiredate) */ ename, hiredate
		  from emp
		  where hiredate < to_date ( '9999/12/31', 'rrrr/mm/dd' )
		    and rownum = 1;
		=============================
		ENAME                HIREDATE
		-------------------- --------
		SMITH                80/12/09
		=============================
		---------------------------------------
		| Id  | Operation                     |
		---------------------------------------
		|   0 | SELECT STATEMENT              |
		|*  1 |  COUNT STOPKEY                |
		|   2 |   TABLE ACCESS BY INDEX ROWID |
		|*  3 |    INDEX RANGE SCAN DESCENDING|
		---------------------------------------
		==================
		0  db block gets
		2  consistent gets
		0  physical reads
		==================


문제 34. 아래의 SQL을 튜닝하시오 !
	튜닝전 : 
		select ename, sal
		  from emp e
		  where sal > (select avg(sal)
				 from emp s
				 where s.deptno = e.deptno);
		===============================
		ENAME                       SAL
		-------------------- ----------
		KING                       5000
		BLAKE                      2850
		JONES                      2975
		ALLEN                      1600
		FORD                       3000
		SCOTT                      3000
		===============================
		------------------------------------
		| Id  | Operation           | Name |
		------------------------------------
		|   0 | SELECT STATEMENT    |      |
		|*  1 |  FILTER             |      |
		|   2 |   TABLE ACCESS FULL | EMP  |
		|   3 |   SORT AGGREGATE    |      |
		|*  4 |    TABLE ACCESS FULL| EMP  |
		------------------------------------
		===================
		 0  db block gets
		13  consistent gets
		 0  physical reads
		===================
	튜닝전 : 
		select ename, sal
		  from (select ename, sal, avg(sal) over ( partition by deptno) avg
			  from emp)
		  where sal > avg;
		===============================
		ENAME                       SAL
		-------------------- ----------
		KING                       5000
		SCOTT                      3000
		FORD                       3000
		JONES                      2975
		ALLEN                      1600
		BLAKE                      2850
		===============================
		------------------------------------
		| Id  | Operation           | Name |
		------------------------------------
		|   0 | SELECT STATEMENT    |      |
		|*  1 |  VIEW               |      |
		|   2 |   WINDOW SORT       |      |
		|   3 |    TABLE ACCESS FULL| EMP  |
		------------------------------------
		==================
		0  db block gets
		3  consistent gets
		0  physical reads
		==================

			※ inline view는 TABLE ACCESS 를 1번 한다.


문제 35. 아래의 SQL을 튜닝하시오 !
	튜닝전 :
		select ename, sal, job
		  from emp e
		  where 4 <= (select count(*)
				from emp s
				where s.job = e.job);
		==================================================
		ENAME                       SAL JOB
		-------------------- ---------- ------------------
		MARTIN                     1250 SALESMAN
		ALLEN                      1600 SALESMAN
		TURNER                     1500 SALESMAN
		JAMES                       950 CLERK
		WARD                       1250 SALESMAN
		SMITH                       800 CLERK
		ADAMS                      1100 CLERK
		MILLER                     1300 CLERK
		==================================================
		------------------------------------
		| Id  | Operation           | Name |
		------------------------------------
		|   0 | SELECT STATEMENT    |      |
		|*  1 |  FILTER             |      |
		|   2 |   TABLE ACCESS FULL | EMP  |
		|   3 |   SORT AGGREGATE    |      |
		|*  4 |    TABLE ACCESS FULL| EMP  |
		------------------------------------
		===================
		 0  db block gets
		19  consistent gets
		 0  physical reads
		===================

	튜닝후 : 
		select ename, sal, job
		  from (select ename, sal, job, count(*) over (partition by job) cnt
			  from emp)
		  where cnt >= 4;
		==================================================
		ENAME                       SAL JOB
		-------------------- ---------- ------------------
		SMITH                       800 CLERK
		MILLER                     1300 CLERK
		JAMES                       950 CLERK
		ADAMS                      1100 CLERK
		WARD                       1250 SALESMAN
		ALLEN                      1600 SALESMAN
		MARTIN                     1250 SALESMAN
		TURNER                     1500 SALESMAN
		==================================================
		------------------------------------
		| Id  | Operation           | Name |
		------------------------------------
		|   0 | SELECT STATEMENT    |      |
		|*  1 |  VIEW               |      |
		|   2 |   WINDOW SORT       |      |
		|   3 |    TABLE ACCESS FULL| EMP  |
		------------------------------------
		==================
		0  db block gets
		3  consistent gets
		0  physical reads
		==================


문제 36. 아래의 SQL을 튜닝하시오 !
	튜닝전 : 
		select job, sum(sal)
		  from emp
		  group by job
		union
		select null as job, sum(sal)
		  from emp;
		=============================
		JOB                  SUM(SAL)
		------------------ ----------
		ANALYST                  6000
		CLERK                    4150
		MANAGER                  8275
		PRESIDENT                5000
		SALESMAN                 5600
		                        29025
		=============================
		-------------------------------------
		| Id  | Operation            | Name |
		-------------------------------------
		|   0 | SELECT STATEMENT     |      |
		|   1 |  SORT UNIQUE         |      |
		|   2 |   UNION-ALL          |      |
		|   3 |    HASH GROUP BY     |      |
		|   4 |     TABLE ACCESS FULL| EMP  |
		|   5 |    SORT AGGREGATE    |      |
		|   6 |     TABLE ACCESS FULL| EMP  |
		-------------------------------------
		==================
		0  db block gets
		6  consistent gets
		0  physical reads
		==================

	튜닝후 : 
		select job, sum(sal)
		  from emp
		  group by rollup(job);
		=============================
		JOB                  SUM(SAL)
		------------------ ----------
		ANALYST                  6000
		CLERK                    4150
		MANAGER                  8275
		PRESIDENT                5000
		SALESMAN                 5600
		                        29025
		=============================		
		-------------------------------------
		| Id  | Operation            | Name |
		-------------------------------------
		|   0 | SELECT STATEMENT     |      |
		|   1 |  SORT GROUP BY ROLLUP|      |
		|   2 |   TABLE ACCESS FULL  | EMP  |
		-------------------------------------
		==================
		0  db block gets
		3  consistent gets
		0  physical reads
		==================

문제 37. 아래의 SQL의 결과를 union all로 변경하시오 !
	튜닝전 :
		select deptno, job, avg(sal)
		  from emp
		  group by grouping sets( (deptno), (job) );
		========================================
		    DEPTNO JOB                  AVG(SAL)
		---------- ------------------ ----------
		        30                    1566.66667
		        20                          2175
		        10                    2916.66667
		           SALESMAN                 1400
		           CLERK                  1037.5
		           PRESIDENT                5000
		           MANAGER            2758.33333
		           ANALYST                  3000
		========================================
		----------------------------------------------------------------
		| Id  | Operation                  | Name                      |
		----------------------------------------------------------------
		|   0 | SELECT STATEMENT           |                           |
		|   1 |  TEMP TABLE TRANSFORMATION |                           |
		|   2 |   LOAD AS SELECT           | SYS_TEMP_0FD9D6602_2CAC9C |
		|   3 |    TABLE ACCESS FULL       | EMP                       |
		|   4 |   LOAD AS SELECT           | SYS_TEMP_0FD9D6603_2CAC9C |
		|   5 |    HASH GROUP BY           |                           |
		|   6 |     TABLE ACCESS FULL      | SYS_TEMP_0FD9D6602_2CAC9C |
		|   7 |   LOAD AS SELECT           | SYS_TEMP_0FD9D6603_2CAC9C |
		|   8 |    HASH GROUP BY           |                           |
		|   9 |     TABLE ACCESS FULL      | SYS_TEMP_0FD9D6602_2CAC9C |
		|  10 |   VIEW                     |                           |
		|  11 |    TABLE ACCESS FULL       | SYS_TEMP_0FD9D6603_2CAC9C |
		----------------------------------------------------------------
		====================
		 28  db block gets
		105  consistent gets
		  3  physical reads
		====================

		select deptno, null as job, avg(sal)
		  from emp
		  group by deptno
		union all
		select null as deptno, job, avg(sal)
		  from emp
		  group by job;
		========================================
		    DEPTNO JOB                  AVG(SAL)
		---------- ------------------ ----------
		        30                    1566.66667
		        20                          2175
		        10                    2916.66667
		           SALESMAN                 1400
		           CLERK                  1037.5
		           PRESIDENT                5000
		           MANAGER            2758.33333
		           ANALYST                  3000
		========================================
		------------------------------------
		| Id  | Operation           | Name |
		------------------------------------
		|   0 | SELECT STATEMENT    |      |
		|   1 |  UNION-ALL          |      |
		|   2 |   HASH GROUP BY     |      |
		|   3 |    TABLE ACCESS FULL| EMP  |
		|   4 |   HASH GROUP BY     |      |
		|   5 |    TABLE ACCESS FULL| EMP  |
		------------------------------------
		===================
		 0  db block gets
		18  consistent gets
		 0  physical reads
		===================

	튜닝후 :
		select /*+ expand_gset_to_union */ deptno, job, avg(sal)
		  from emp
		  group by grouping sets( (deptno), (job) );
			※ 설명 : expand_gset_to_union 힌트는?
				오라클 옵티마이져에게 SQL을 네가 union all로 작성해라라고 명령을 내리는
				힌트

		========================================
		    DEPTNO JOB                  AVG(SAL)
		---------- ------------------ ----------
		        30                    1566.66667
		        20                          2175
		        10                    2916.66667
		           SALESMAN                 1400
		           CLERK                  1037.5
		           PRESIDENT                5000
		           MANAGER            2758.33333
		           ANALYST                  3000
		========================================
		-------------------------------------
		| Id  | Operation            | Name |
		-------------------------------------
		|   0 | SELECT STATEMENT     |      |
		|   1 |  VIEW                |      |
		|   2 |   UNION-ALL          |      |
		|   3 |    HASH GROUP BY     |      |
		|   4 |     TABLE ACCESS FULL| EMP  |
		|   5 |    HASH GROUP BY     |      |
		|   6 |     TABLE ACCESS FULL| EMP  |
		-------------------------------------
		==================
		0  db block gets
		6  consistent gets
		0  physical reads
		==================












■ 조인 문장 튜닝

	* 조인의 방법 3가지

		1. nested loop 조인
		2. hash 조인
		3. sort merge 조인





★ nested  loop  join
    중첩   루프  조인

	"조인하려는 데이터의 양이 작은 경우는 nested loop조인이 유리하다."

	dept -----------------> emp
	10 ------------------>┐10
	20		      |	10
	30		      |	20
	40		      |	30
			      |	10
			      |	 :
			     ↓	 :
				14건
		모든 경우의 수로 조인한다.

문제 38. 이름과 부서위치를 출력하는 조인문장의 실행계획을 보고 emp테이블을 먼저 읽고 dept랑 조인했는지
	 dept테이블을 먼저 읽고 emp랑 조인했는지 알아내시오 !

@demobld

	select e.ename, d.deptno
	  from emp e, dept d
	  where e.deptno = d.deptno;

		-----------------------------------
		| Id  | Operation          | Name |
		-----------------------------------		읽는 순서
		|   0 | SELECT STATEMENT   |      |		    4
		|*  1 |  HASH JOIN         |      |		    3
		|   2 |   TABLE ACCESS FULL| DEPT |		    1
		|   3 |   TABLE ACCESS FULL| EMP  |		    2
		-----------------------------------
		===================
		 0  db block gets
		21  consistent gets
		 0  physical reads
		===================
		※ 읽는 순서가 안쪽에서부터 읽는다, 
		※ 성능을 따져보면 dept를 먼저 읽는게 빠를까? emp를 먼저 읽는게 빠를까?
			테이블이 작은걸 먼저 읽는게 빠르다
			그래서 옵티마이져가 똑똑하게 dept를 먼저 읽은 것이다.
				dept ------> emp  O
				emp -------> dept X

	 * nested loop join을 사용하려면 ?

	select /*+ use_nl(d e) */ e.ename, d.deptno
	  from emp e, dept d
	  where e.deptno = d.deptno;
		-----------------------------------
		| Id  | Operation          | Name |
		-----------------------------------
		|   0 | SELECT STATEMENT   |      |
		|   1 |  NESTED LOOPS      |      |
		|   2 |   TABLE ACCESS FULL| DEPT |
		|*  3 |   TABLE ACCESS FULL| EMP  |
		-----------------------------------
		===================
		 0  db block gets
		17  consistent gets
		 0  physical reads
		===================

	* 조인 하는 순서를 변경하는 힌트
		1. ordered : from 절에서 기술한 순서대로 조인하겠다.

	select /*+ ordered use_nl(d e) */ e.ename, d.deptno
	  from emp e, dept d
	  where e.deptno = d.deptno;
		-----------------------------------
		| Id  | Operation          | Name |
		-----------------------------------
		|   0 | SELECT STATEMENT   |      |
		|   1 |  NESTED LOOPS      |      |
		|   2 |   TABLE ACCESS FULL| EMP  |
		|*  3 |   TABLE ACCESS FULL| DEPT |
		-----------------------------------
		===================
		 0  db block gets
		47  consistent gets
		 0  physical reads
		===================
	select /*+ ordered use_nl(d e) */ e.ename, d.deptno
	  from dept d, emp e
	  where e.deptno = d.deptno;
		-----------------------------------
		| Id  | Operation          | Name |
		-----------------------------------
		|   0 | SELECT STATEMENT   |      |
		|   1 |  NESTED LOOPS      |      |
		|   2 |   TABLE ACCESS FULL| DEPT |
		|*  3 |   TABLE ACCESS FULL| EMP  |
		-----------------------------------
		===================
		 0  db block gets
		17  consistent gets
		 0  physical reads
		===================


		2. leading : leading 힌트 안에 쓴 테이블 순서대로 조인하겠다.

	select /*+ leading(e d) use_nl(d e) */ e.ename, d.deptno
	  from emp e, dept d
	  where e.deptno = d.deptno;


문제 39. emp와 salgrade와 dept를 조인해서 이름과 월급과 부서위치, 급여등급을 출력하시오 !

	select e.ename, e.sal, d.loc, s.grade
	  from emp e, dept d, salgrade s
	  where e.deptno = d.deptno
	    and e.sal between s.losal and s.hisal;
		------------------------------------------
		| Id  | Operation             | Name     |
		------------------------------------------
		|   0 | SELECT STATEMENT      |          |
		|*  1 |  HASH JOIN            |          |
		|   2 |   MERGE JOIN CARTESIAN|          |
		|   3 |    TABLE ACCESS FULL  | DEPT     |
		|   4 |    BUFFER SORT        |          |
		|   5 |     TABLE ACCESS FULL | SALGRADE |
		|   6 |   TABLE ACCESS FULL   | EMP      |
		------------------------------------------
		===================
		 0  db block gets
		32  consistent gets
		 0  physical reads
		===================


문제 40. 위의 조인문장의 조인순서와 조인 방법을 아래의 방법으로 수행하시오 !

	조인 순서 : salgrade ---> enp ---> dept
	                      ↑       ↑ 
	조인 방법 : nested ioop join   nested ioop join

	select /*+ leading(s e d) use_nl(e) use_nl(d) */ e.ename, e.sal, d.loc, s.grade
	  from emp e, dept d, salgrade s
	  where e.deptno = d.deptno
	    and e.sal between s.losal and s.hisal;
		----------------------------------------
		| Id  | Operation           | Name     |
		----------------------------------------
		|   0 | SELECT STATEMENT    |          |	5
		|   1 |  NESTED LOOPS       |          |	4
		|   2 |   NESTED LOOPS      |          |	3
		|   3 |    TABLE ACCESS FULL| SALGRADE |	1
		|*  4 |    TABLE ACCESS FULL| EMP      |	2
		|*  5 |   TABLE ACCESS FULL | DEPT     |	4
		----------------------------------------
		===================
		 0  db block gets
		75  consistent gets
		 0  physical reads
		===================
		※힌트 해석 : salgrade, emp 그리고 dept 순서로 읽는데[leading(s e d)] 첫번째로 읽은것과
			      emp테이블 을 nested ioop join[use_nl(e)] 하고
			      조인한 테이블과 dept테이블을 nested ioop join[use_nl(d)] 한다.


문제 41. 위의 SQL이 아래와 같은 조인순서로 실행되게 하시오 !

	조인 순서 : DEPT ---> EMP ---> SALGRADE
	                      ↑       ↑ 
	조인 방법 : nested ioop join   nested ioop join

	select /*+ leading(d e s) use_nl(e) use_nl(s) */ e.ename, e.sal, d.loc, s.grade
	  from emp e, dept d, salgrade s
	  where e.deptno = d.deptno
	    and e.sal between s.losal and s.hisal;

		----------------------------------------
		| Id  | Operation           | Name     |
		----------------------------------------
		|   0 | SELECT STATEMENT    |          |
		|   1 |  NESTED LOOPS       |          |
		|   2 |   NESTED LOOPS      |          |
		|   3 |    TABLE ACCESS FULL| DEPT     |
		|*  4 |    TABLE ACCESS FULL| EMP      |
		|*  5 |   TABLE ACCESS FULL | SALGRADE |
		----------------------------------------
		===================
		 0  db block gets
		59  consistent gets
		 0  physical reads
		===================


* 현업버전

===========================
create table  sales600
 as
 select *
  from  sales;

 create table customers600
 as
  select *
  from customers;
===========================

SELECT /*+ leading(s c) use_nl(c) */  COUNT(*) 
     FROM sales600 s, customers600 c 
     WHERE s.cust_id = c.cust_id           
     AND c.country_id = 52790  
     AND s.time_id BETWEEN TO_DATE('1999/01/01','YYYY/MM/DD')  
                       AND TO_DATE('1999/12/31','YYYY/MM/DD');
	※ 너무 오래걸려서 스톱함 (ctrl + c)


SELECT /*+ leading(c s) use_nl(s) */  COUNT(*) 
     FROM sales600 s, customers600 c 
     WHERE s.cust_id = c.cust_id           
     AND c.country_id = 52790  
     AND s.time_id BETWEEN TO_DATE('1999/01/01','YYYY/MM/DD')  
                       AND TO_DATE('1999/12/31','YYYY/MM/DD');

------------------------------------------------------------------------------------
| Id  | Operation           | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |              |     1 |    48 |    19M  (1)| 63:31:43 |
|   1 |  SORT AGGREGATE     |              |     1 |    48 |            |          |
|   2 |   NESTED LOOPS      |              |   233K|    10M|    19M  (1)| 63:31:43 |
|*  3 |    TABLE ACCESS FULL| CUSTOMERS600 | 15810 |   401K|   417   (1)| 00:00:06 |
|*  4 |    TABLE ACCESS FULL| SALES600     |    15 |   330 |  1205   (1)| 00:00:15 |
------------------------------------------------------------------------------------
=========================
       0  db block gets
82137735  consistent gets
       0  physical reads
=========================



문제 42. (오늘의 마지막 문제 ) 아래의 SQL을 튜닝하시오 !
	 (무조건 nested loop 조인으로 수행하되 가장 좋은 조인순서를 결정하시오 ! )

		create  table sales100  as  select  * from sales;
		create  table times100  as  select  * from times;
		create  table products100 as select * from products;
	
	튜닝 전 :
		select /*+ leading(s t p) use_nl(t) use_nl(p) */ 
		  p.prod_name, t.CALENDAR_YEAR, sum(s.amount_sold)
		  from   sales100  s, times100  t, products100  p
		  where   s.time_id = t.time_id
		  and  s.prod_id = p.prod_id
		    and  t.CALENDAR_YEAR in (2000,2001)
		    and p.prod_name like 'Deluxe%'
		    group  by  p.prod_name, t.calendar_year;



	답1 :
		select /*+ leading(p s t) use_nl(s) use_nl(t) */ 
		       p.prod_name, 
                       t.CALENDAR_YEAR, 
                       sum(s.amount_sold)
		  from   sales100     s,				/* 데이터 918,843건 */ 
          		 times100     t,				/* 데이터   1,826건 */
                         products100  p					/* 데이터      72건 */
		  where  s.time_id = t.time_id 				/* s,t 연결고리 */
		    and  s.prod_id = p.prod_id   			/* s,p 연결고리 */
		    and  t.CALENDAR_YEAR in (2000,2001)			/* times100 731건 */
		    and  p.prod_name like 'Deluxe%'			/* products100 1건 */
		    group  by  p.prod_name, t.calendar_year;

        /* 테이블 데이터 건수로만따지면 p-t-s가 가장 빠를것 같지만 조인연결고리가 훼손된다.
           테이블의 연결고리가 t-s-p이기 때문에 연결고리를 훼손하지 않는 선에서 
           p-s-t(72건-918,843건-1,826건)순서로 엑세스하는 것이 가장 빠를 것으로 예상된다. */;

		=================================
		Deluxe Mouse	2001	142334.42
		Deluxe Mouse	2000	53224.73
		=================================
		경   과: 00:00:02.96
		====================
		------------------------------------------------------------------------------------
		| Id  | Operation            | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
		------------------------------------------------------------------------------------
		|   0 | SELECT STATEMENT     |             | 19750 |  2835K|   323K  (1)| 01:04:41 |
		|   1 |  HASH GROUP BY       |             | 19750 |  2835K|   323K  (1)| 01:04:41 |
		|   2 |   NESTED LOOPS       |             | 19750 |  2835K|   323K  (1)| 01:04:41 |
		|   3 |    NESTED LOOPS      |             | 19750 |  2410K|  1383   (1)| 00:00:17 |
		|*  4 |     TABLE ACCESS FULL| PRODUCTS100 |     1 |    90 |     2   (0)| 00:00:01 |
		|*  5 |     TABLE ACCESS FULL| SALES100    | 19750 |   675K|  1381   (1)| 00:00:17 |
		|*  6 |    TABLE ACCESS FULL | TIMES100    |     1 |    22 |    16   (0)| 00:00:01 |
		------------------------------------------------------------------------------------
		=======================
		     0  db block gets
		813943  consistent gets
		  5060  physical reads
		=======================


선생님 설명
1. products 테이블에서 p.prod_name like 'Deruxe%' 조건의 데이터 1건을 찾아낸다.

2. 1건의 prod_id 47번을 sales100테이블에 조인시도를 한다(1건밖에 없으므로 1번만 조인시도 한다.)

3. prod_id 47번을 sales100테이블에서 12837건을 찾아낸다.

4. prod_id 12837건을 times100 테이블로 조인시도를 한다 (조인 시도가 12837 번)

5. times100 테이블로 조인 시도한 12837건중에 CALENDAR_YEAR in (2000,2001)조건에 만족한 것만 결과로 
   출력된다.


		중첩 루프 조인   ---------->   이중 루프문 프로그램

		loop ......
		   loop.......
		  end loop......
		    loop.....


sql plus에서 전체 걸린 시간 확인하려면 set timing on 하면 됩니다.
