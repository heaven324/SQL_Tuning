■ 이번주 일정

월				화	수	목	금	토
↓				↓			↓
SQL 튜닝 노트정리 제출		파이썬			SQL재시험


파이썬 --> 딥러닝 --> 리눅스 --> 하둡 --> R --> 포트폴리오


■ SQL 튜닝 복습 

	1. SQL 튜닝을 왜 배워야 하는가 ?
	2. 인덱스 튜닝
		- index range scan
		- index unique scan
		- index skip scan
		- index full scan
		- index fast scan
		- index merge scan
		- index bitmap merge scan
		- index join

	3. 조인 문장 튜닝
		- nested loop join
			"조인되는 건수가 얼마 안될 때 사용하는 조인 방법"
			 조인되는 연결고리에 인덱스의 유무에 따라 성능이 크게 차이가 난다!
		- hash join
			"조인되는 데이터의 양이 대용량일 때 사용하는 조인 방법"
			 인덱스를 엑세스하기보다 full table scan이 오히려 성능이 유리하다.

			힌트 : /*+ leading(d e) use_hash(e) full(d) full(e)
				   parallel(d 4) parallel(e 4) */

				leading은 조인 순서를 결정하는 힌트
				use_hash는 메모리에서 조인하는 해쉬조인을 유도하는 힌트
				full은 full table scan하라고 하는 힌트
				parallel은 full table scan을 빠르게 하기위해 병렬로 작업하라는 힌트
				병렬처리의 숫자는 크면클수록 좋은 것인데 줄수있는 것을 확인하고 줘야 
				한다.
		SQL> show parameter cpu_count
		
		NAME                                 TYPE                   VALUE
		------------------------------------ ---------------------- -----
		cpu_count                            integer                8
			 - 8*2 해서 16까지 줄 수 있다.
			   cpu카운트의  *2 만큼 병렬처리를 줄수 있기 때문
			   하지만 16을 주면 cpu를 100까지 쓰겠다는 건데 그럼 다른 작업을 할 수 없다
			   그래서 적당히 높은 숫자를 써주는 것이 좋다 ( 4 ~ 8 )

	12c에서 병렬처리 예
	C:\Users\Administrator>set oracle_sid=orcl

	C:\Users\Administrator>sqlplus / as sysdba
	
	SQL> alter session set container=pdborcl;
	
	세션이 변경되었습니다.
	
	SQL> alter database pdborcl open;
	
	데이타베이스가 변경되었습니다.
	
	SQL> connect scott/tiger@localhost:1522/pdborcl
	
	SQL> set autot traceonly explain
	
	select /*+  leading(d e) use_hash(e)
	                  full(d)  full(e)
	           parallel(d 16)  parallel(e 4)  */
	        e.ename,  d.loc
	 from  emp  e, dept  d
	 where  e.deptno = d.deptno ;
	
	----------------------------------------------------------------------------
	| Id  | Operation                  | Name     | Rows  | Bytes | Cost (%CPU)|
	----------------------------------------------------------------------------
	|   0 | SELECT STATEMENT           |          |    14 |   280 |     4   (0)|
	|   1 |  PX COORDINATOR            |          |       |       |            |
	|   2 |   PX SEND QC (RANDOM)      | :TQ10002 |    14 |   280 |     4   (0)|
	|*  3 |    HASH JOIN BUFFERED      |          |    14 |   280 |     4   (0)|
	|   4 |     PX RECEIVE             |          |     4 |    44 |     2   (0)|
	|   5 |      PX SEND HYBRID HASH   | :TQ10000 |     4 |    44 |     2   (0)|
	|   6 |       STATISTICS COLLECTOR |          |       |       |            |
	|   7 |        PX BLOCK ITERATOR   |          |     4 |    44 |     2   (0)|
	|   8 |         TABLE ACCESS FULL  | DEPT     |     4 |    44 |     2   (0)|
	|   9 |     PX RECEIVE             |          |    14 |   126 |     2   (0)|
	|  10 |      PX SEND HYBRID HASH   | :TQ10001 |    14 |   126 |     2   (0)|
	|  11 |       PX BLOCK ITERATOR    |          |    14 |   126 |     2   (0)|
	|  12 |        TABLE ACCESS FULL   | EMP      |    14 |   126 |     2   (0)|
	----------------------------------------------------------------------------
	----------------------------------------
	 Time     |    TQ  |IN-OUT| PQ Distrib |
	----------------------------------------
	 00:00:01 |        |      |            |
	          |        |      |            |
	 00:00:01 |  Q1,02 | P->S | QC (RAND)  |
	 00:00:01 |  Q1,02 | PCWP |            |
	 00:00:01 |  Q1,02 | PCWP |            |
	 00:00:01 |  Q1,00 | P->P | HYBRID HASH|
	          |  Q1,00 | PCWC |            |
	 00:00:01 |  Q1,00 | PCWC |            |
	 00:00:01 |  Q1,00 | PCWP |            |
	 00:00:01 |  Q1,02 | PCWP |            |
	 00:00:01 |  Q1,01 | P->P | HYBRID HASH|
	 00:00:01 |  Q1,01 | PCWC |            |
	 00:00:01 |  Q1,01 | PCWP |            |
	----------------------------------------

		- sort merge join
			"


문제 60. 아래의 SQL을 튜닝하시오! (병렬도 힌트와 FULL힌트를 사용해서 작성하시오 !

		create table sales100
		as
		select * from sh.sales;
	
		create table times100
		as
		select * from sh.times;
	튜닝전 :
		select t.calendar_year, sum(s.amount_sold)
		  from sales100 s, times100 t
		  where s.time_id = t.time_id(+)
		    and t.week_ending_day_id = 1581
		  group by t.calendar_year;

	CALENDAR_YEAR SUM(S.AMOUNT_SOLD)
	------------- ------------------
	         1998          438660.26
	
	경   과: 00:00:01.35
	--------------------------------------------------------------------------------
	| Id  | Operation           | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
	--------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT    |          |     4 |   116 |  1252   (1)| 00:00:01 |
	|   1 |  HASH GROUP BY      |          |     4 |   116 |  1252   (1)| 00:00:01 |
	|*  2 |   HASH JOIN         |          |  4386 |   124K|  1251   (1)| 00:00:01 |
	|*  3 |    TABLE ACCESS FULL| TIMES100 |     7 |   112 |    17   (0)| 00:00:01 |
	|   4 |    TABLE ACCESS FULL| SALES100 |   918K|    11M|  1231   (1)| 00:00:01 |
	--------------------------------------------------------------------------------
	          0  db block gets
	       4492  consistent gets
	       4485  physical reads

	튜닝후 :
		select /*+ leading(t s) use_hash(s) full(t) full(s) parallel(t 4) parallel(s 4) */
		       t.calendar_year, sum(s.amount_sold)
		  from sales100 s, times100 t
		  where s.time_id = t.time_id(+)
		    and t.week_ending_day_id = 1581
		  group by t.calendar_year;

	CALENDAR_YEAR SUM(S.AMOUNT_SOLD)
	------------- ------------------
	         1998          438660.26
	
	경   과: 00:00:00.40
	----------------------------------------------------------------------------
	| Id  | Operation                  | Name     | Rows  | Bytes | Cost (%CPU)|
	----------------------------------------------------------------------------
	|   0 | SELECT STATEMENT           |          |     4 |   116 |   348   (1)|
	|   1 |  PX COORDINATOR            |          |       |       |            |
	|   2 |   PX SEND QC (RANDOM)      | :TQ10001 |     4 |   116 |   348   (1)|
	|   3 |    HASH GROUP BY           |          |     4 |   116 |   348   (1)|
	|   4 |     PX RECEIVE             |          |     4 |   116 |   348   (1)|
	|   5 |      PX SEND HASH          | :TQ10000 |     4 |   116 |   348   (1)|
	|   6 |       HASH GROUP BY        |          |     4 |   116 |   348   (1)|
	|*  7 |        HASH JOIN           |          |  4386 |   124K|   347   (1)|
	|   8 |         JOIN FILTER CREATE | :BF0000  |     7 |   112 |     5   (0)|
	|*  9 |          TABLE ACCESS FULL | TIMES100 |     7 |   112 |     5   (0)|
	|  10 |         JOIN FILTER USE    | :BF0000  |   918K|    11M|   342   (1)|
	|  11 |          PX BLOCK ITERATOR |          |   918K|    11M|   342   (1)|
	|* 12 |           TABLE ACCESS FULL| SALES100 |   918K|    11M|   342   (1)|
	----------------------------------------------------------------------------
	----------------------------------------
	 Time     |    TQ  |IN-OUT| PQ Distrib |
	----------------------------------------
	 00:00:01 |        |      |            |
	          |        |      |            |
	 00:00:01 |  Q1,01 | P->S | QC (RAND)  |
	 00:00:01 |  Q1,01 | PCWP |            |
	 00:00:01 |  Q1,01 | PCWP |            |
	 00:00:01 |  Q1,00 | P->P | HASH       |
	 00:00:01 |  Q1,00 | PCWP |            |
	 00:00:01 |  Q1,00 | PCWP |            |
	 00:00:01 |  Q1,00 | PCWP |            |
	 00:00:01 |  Q1,00 | PCWP |            |
	 00:00:01 |  Q1,00 | PCWP |            |
	 00:00:01 |  Q1,00 | PCWC |            |
	 00:00:01 |  Q1,00 | PCWP |            |
	----------------------------------------
	          0  db block gets
	       4498  consistent gets
	       4433  physical reads
	

문제 61. 아래의 SQL을 튜닝하시오 !
	튜닝전 :
		select /*+ leading(s t) use_hash(t) swap_join_inputs(s) */
		       t.calendar_year, sum(s.amount_sold)
		  from sales100 s, times100 t
		  where s.time_id = t.time_id(+)
		  group by t.calendar_year;

	CALENDAR_YEAR SUM(S.AMOUNT_SOLD)
	------------- ------------------
	         1999         22219947.7
	         2001           28136462
	         1998           24083915
	         2000         23765506.6
	
	경   과: 00:00:00.51
	----------------------------------------------------------------------------------------
	| Id  | Operation           | Name     | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
	----------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT    |          |     5 |   125 |       |  2366   (2)| 00:00:01 |
	|   1 |  HASH GROUP BY      |          |     5 |   125 |       |  2366   (2)| 00:00:01 |
	|*  2 |   HASH JOIN OUTER   |          |   918K|    21M|    21M|  2344   (1)| 00:00:01 |
	|   3 |    TABLE ACCESS FULL| SALES100 |   918K|    11M|       |  1231   (1)| 00:00:01 |
	|   4 |    TABLE ACCESS FULL| TIMES100 |  1826 | 21912 |       |    17   (0)| 00:00:01 |
	----------------------------------------------------------------------------------------
	          0  db block gets
	       4492  consistent gets
	       4433  physical reads

	튜닝후 1 :
		select /*+ leading(t s) use_hash(s) swap_join_inputs(t) */
		       t.calendar_year, sum(s.amount_sold)
		  from sales100 s, times100 t
		  where s.time_id = t.time_id(+)
		  group by t.calendar_year;

	CALENDAR_YEAR SUM(S.AMOUNT_SOLD)
	------------- ------------------
	         1999         22219947.7
	         2001           28136462
	         1998           24083915
	         2000         23765506.6
	
	경   과: 00:00:00.40
	-----------------------------------------------------------------------------------
	| Id  | Operation              | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
	-----------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT       |          |     5 |   125 |  1273   (3)| 00:00:01 |
	|   1 |  HASH GROUP BY         |          |     5 |   125 |  1273   (3)| 00:00:01 |
	|*  2 |   HASH JOIN RIGHT OUTER|          |   918K|    21M|  1251   (1)| 00:00:01 |
	|   3 |    TABLE ACCESS FULL   | TIMES100 |  1826 | 21912 |    17   (0)| 00:00:01 |
	|   4 |    TABLE ACCESS FULL   | SALES100 |   918K|    11M|  1231   (1)| 00:00:01 |
	-----------------------------------------------------------------------------------
	          0  db block gets
	       4492  consistent gets
	       4433  physical reads

	튜닝후 2 :
		select /*+ leading(t s) use_hash(s) swap_join_inputs(t) full(t) full(s)
			   parallel(t 4) parallel(s 4) */
		       t.calendar_year, sum(s.amount_sold)
		  from sales100 s, times100 t
		  where s.time_id = t.time_id(+)
		  group by t.calendar_year;

	CALENDAR_YEAR SUM(S.AMOUNT_SOLD)
	------------- ------------------
	         1999         22219947.7
	         2001           28136462
	         1998           24083915
	         2000         23765506.6
	
	경   과: 00:00:00.39
	-----------------------------------------------------------------------------
	| Id  | Operation                   | Name     | Rows  | Bytes | Cost (%CPU)|
	-----------------------------------------------------------------------------
	|   0 | SELECT STATEMENT            |          |     5 |   125 |   354   (3)|
	|   1 |  PX COORDINATOR             |          |       |       |            |
	|   2 |   PX SEND QC (RANDOM)       | :TQ10001 |     5 |   125 |   354   (3)|
	|   3 |    HASH GROUP BY            |          |     5 |   125 |   354   (3)|
	|   4 |     PX RECEIVE              |          |     5 |   125 |   354   (3)|
	|   5 |      PX SEND HASH           | :TQ10000 |     5 |   125 |   354   (3)|
	|   6 |       HASH GROUP BY         |          |     5 |   125 |   354   (3)|
	|*  7 |        HASH JOIN RIGHT OUTER|          |   918K|    21M|   347   (1)|
	|   8 |         TABLE ACCESS FULL   | TIMES100 |  1826 | 21912 |     5   (0)|
	|   9 |         PX BLOCK ITERATOR   |          |   918K|    11M|   342   (1)|
	|  10 |          TABLE ACCESS FULL  | SALES100 |   918K|    11M|   342   (1)|
	-----------------------------------------------------------------------------
	----------------------------------------
	 Time     |    TQ  |IN-OUT| PQ Distrib |
	----------------------------------------
	 00:00:01 |        |      |            |
	          |        |      |            |
	 00:00:01 |  Q1,01 | P->S | QC (RAND)  |
	 00:00:01 |  Q1,01 | PCWP |            |
	 00:00:01 |  Q1,01 | PCWP |            |
	 00:00:01 |  Q1,00 | P->P | HASH       |
	 00:00:01 |  Q1,00 | PCWP |            |
	 00:00:01 |  Q1,00 | PCWP |            |
	 00:00:01 |  Q1,00 | PCWP |            |
	 00:00:01 |  Q1,00 | PCWC |            |
	 00:00:01 |  Q1,00 | PCWP |            |
	----------------------------------------
	          0  db block gets
	       4498  consistent gets
	       4433  physical reads



★ full outer join


문제 62. 아래의 SQL의 결과를 UNION 으로 구현하시오 !

	insert into emp( empno, ename, sal, deptno )
	  values(1929, 'JACK', 4500, 70);

	select e.ename, d.loc
	  from emp e full outer join dept d
	  on (e.deptno = d.deptno);

	ENAME      LOC
	---------- --------
	JACK
	SMITH      DALLAS
	ALLEN      CHICAGO
	WARD       CHICAGO
	JONES      DALLAS
	MARTIN     CHICAGO
	BLAKE      CHICAGO
	CLARK      NEW YORK
	SCOTT      DALLAS
	KING       NEW YORK
	TURNER     CHICAGO
	ADAMS      DALLAS
	JAMES      CHICAGO
	FORD       DALLAS
	MILLER     NEW YORK
	           BOSTON

	경   과: 00:00:00.07
	----------------------------------------------------------------------------------
	| Id  | Operation             | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
	----------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT      |          |    15 |   225 |     6   (0)| 00:00:01 |
	|   1 |  VIEW                 | VW_FOJ_0 |    15 |   225 |     6   (0)| 00:00:01 |
	|*  2 |   HASH JOIN FULL OUTER|          |    15 |   300 |     6   (0)| 00:00:01 |
	|   3 |    TABLE ACCESS FULL  | DEPT     |     4 |    44 |     3   (0)| 00:00:01 |
	|   4 |    TABLE ACCESS FULL  | EMP      |    14 |   126 |     3   (0)| 00:00:01 |
	----------------------------------------------------------------------------------
	          0  db block gets
	         14  consistent gets
	          0  physical reads

	결과 :
		select e.ename, d.loc
		  from emp e, dept d
		  where e.deptno = d.deptno(+)
		union
		select e.ename, d.loc
		  from emp e, dept d
		  where e.deptno(+) = d.deptno;

	ENAME      LOC
	---------- --------
	ADAMS      DALLAS
	ALLEN      CHICAGO
	BLAKE      CHICAGO
	CLARK      NEW YORK
	FORD       DALLAS
	JACK
	JAMES      CHICAGO
	JONES      DALLAS
	KING       NEW YORK
	MARTIN     CHICAGO
	MILLER     NEW YORK
	SCOTT      DALLAS
	SMITH      DALLAS
	TURNER     CHICAGO
	WARD       CHICAGO
	           BOSTON

	경   과: 00:00:00.06
	------------------------------------------------------------------------------------------
	| Id  | Operation                      | Name    | Rows  | Bytes | Cost (%CPU)| Time     |
	------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT               |         |    29 |   580 |    14  (22)| 00:00:01 |
	|   1 |  SORT UNIQUE                   |         |    29 |   580 |    14  (22)| 00:00:01 |
	|   2 |   UNION-ALL                    |         |       |       |            |          |
	|*  3 |    HASH JOIN OUTER             |         |    14 |   280 |     6   (0)| 00:00:01 |
	|   4 |     TABLE ACCESS FULL          | EMP     |    14 |   126 |     3   (0)| 00:00:01 |
	|   5 |     TABLE ACCESS FULL          | DEPT    |     4 |    44 |     3   (0)| 00:00:01 |
	|   6 |    MERGE JOIN OUTER            |         |    15 |   300 |     6  (17)| 00:00:01 |
	|   7 |     TABLE ACCESS BY INDEX ROWID| DEPT    |     4 |    44 |     2   (0)| 00:00:01 |
	|   8 |      INDEX FULL SCAN           | PK_DEPT |     4 |       |     1   (0)| 00:00:01 |
	|*  9 |     SORT JOIN                  |         |    14 |   126 |     4  (25)| 00:00:01 |
	|  10 |      TABLE ACCESS FULL         | EMP     |    14 |   126 |     3   (0)| 00:00:01 |
	------------------------------------------------------------------------------------------
	          0  db block gets
	         23  consistent gets
	          0  physical reads

	옛날 버전 방식 :
		 select  /*+   optimizer_features_enable('10.2.0.1')
		        opt_param('_optimizer_native_full_outer_join','off') */  e.ename, d.loc
		   from  emp  e  full  outer  join   dept  d
		   on (e.deptno = d.deptno );

		※ optimizer_features_enable('10.2.0.1') : 옵티머이져를 10g 버전으로 사용하겠다.
		   opt_param('_optimizer_native_full_outer_join','off') :
		   full outer join의 성능을 높이는 파라미터를 끄겠다. (옵션 같은것 !)
								(예 : 카톡의 알림을 무음으로 ! )
	ENAME      LOC
	---------- -------------
	MILLER     NEW YORK
	KING       NEW YORK
	CLARK      NEW YORK
	FORD       DALLAS
	ADAMS      DALLAS
	SCOTT      DALLAS
	JONES      DALLAS
	SMITH      DALLAS
	JAMES      CHICAGO
	TURNER     CHICAGO
	BLAKE      CHICAGO
	MARTIN     CHICAGO
	WARD       CHICAGO
	ALLEN      CHICAGO
	JACK
	           BOSTON

	경   과: 00:00:00.06
	------------------------------------------------------------------------------------------
	| Id  | Operation                      | Name    | Rows  | Bytes | Cost (%CPU)| Time     |
	------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT               |         |    15 |   225 |    13  (16)| 00:00:01 |
	|   1 |  VIEW                          |         |    15 |   225 |    13  (16)| 00:00:01 |
	|   2 |   UNION-ALL                    |         |       |       |            |          |
	|*  3 |    HASH JOIN OUTER             |         |    14 |   280 |     7  (15)| 00:00:01 |
	|   4 |     TABLE ACCESS FULL          | EMP     |    14 |   126 |     3   (0)| 00:00:01 |
	|   5 |     TABLE ACCESS FULL          | DEPT    |     4 |    44 |     3   (0)| 00:00:01 |
	|   6 |    MERGE JOIN ANTI             |         |     1 |    14 |     6  (17)| 00:00:01 |
	|   7 |     TABLE ACCESS BY INDEX ROWID| DEPT    |     4 |    44 |     2   (0)| 00:00:01 |
	|   8 |      INDEX FULL SCAN           | PK_DEPT |     4 |       |     1   (0)| 00:00:01 |
	|*  9 |     SORT UNIQUE                |         |    14 |    42 |     4  (25)| 00:00:01 |
	|  10 |      TABLE ACCESS FULL         | EMP     |    14 |    42 |     3   (0)| 00:00:01 |
	------------------------------------------------------------------------------------------
	          0  db block gets
	         24  consistent gets
	          0  physical reads

	10g 버전에서의 튜닝후:
		 select /*+ opt_param('_optimizer_native_full_outer_join','force') */  
			e.ename, d.loc
		   from  emp  e  full  outer  join   dept  d
		   on (e.deptno = d.deptno );

		※ force : 켜겠다.


문제 63. telecom_price 테이블과 우리반 테이블을 조인해서 학생이름, 나이, 주소, 텔레콤
	 month_price를 출력하시오 !

	alter table telecom_price
	  add month_price number(20);

	update telecom_price set month_price = 56000 where telecom_name = 'sk';
	update telecom_price set month_price = 54000 where telecom_name = 'lg';
	update telecom_price set month_price = 52000 where telecom_name = 'kt';
	update telecom_price set month_price = 50000 where telecom_name = 'cj hello';

	select e.ename, e.age, e.address, e.telecom, t.month_price
	  from emp2 e, telecom_price t
	  where lower(e.telecom) = lower(t.telecom_name);

	경   과: 00:00:00.15
	------------------------------------------------------------------------------------
	| Id  | Operation          | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
	------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |               |     1 |    78 |     5  (20)| 00:00:01 |
	|*  1 |  HASH JOIN         |               |     1 |    78 |     5  (20)| 00:00:01 |
	|   2 |   TABLE ACCESS FULL| TELECOM_PRICE |     4 |    80 |     2   (0)| 00:00:01 |
	|   3 |   TABLE ACCESS FULL| EMP2          |    28 |  1624 |     2   (0)| 00:00:01 |
	------------------------------------------------------------------------------------
	          0  db block gets
	          7  consistent gets
	          0  physical reads


문제 64. 위의 결과에서 통신사가 sk인 학생들만 출력하시오 !
	  (튜닝된 SQL로 작성하시오 !)

	select /*+ leading(t e) use_nl(e) */
		e.ename, e.age, e.address, e.telecom, t.month_price
	  from emp2 e, telecom_price t
	  where lower(e.telecom) = lower(t.telecom_name);
	    and t.telecom_name = 'sk';

	경   과: 00:00:00.10
	------------------------------------------------------------------------------------
	| Id  | Operation          | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
	------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |               |     1 |    78 |     5   (0)| 00:00:01 |
	|   1 |  NESTED LOOPS      |               |     1 |    78 |     5   (0)| 00:00:01 |
	|   2 |   TABLE ACCESS FULL| TELECOM_PRICE |     4 |    80 |     2   (0)| 00:00:01 |
	|*  3 |   TABLE ACCESS FULL| EMP2          |     1 |    58 |     1   (0)| 00:00:01 |
	------------------------------------------------------------------------------------
	          0  db block gets
	         19  consistent gets
	          0  physical reads



문제 65. 서일 학생의 이름과 나이와 주소와 통신사와 month_price를 출력하는데 튜닝된 SQL로 작성하시오 !
	(점심시간 문제)

	select 
		e.ename, e.age, e.address, e.telecom, t.month_price
	  from emp2 e, telecom_price t
	  where lower( e.telecom ) = t.telecom_name
	    and e.ename = '서일';

	경   과: 00:00:00.03
	-------------------------------------------------------------------
	| Id  | Operation                    | Name                       |
	-------------------------------------------------------------------
	|   0 | SELECT STATEMENT             |                            |
	|   1 |  NESTED LOOPS                |                            |
	|   2 |   NESTED LOOPS               |                            |
	|*  3 |    TABLE ACCESS FULL         | EMP2                       |
	|*  4 |    INDEX RANGE SCAN          | TELECOM_PRICE_TELECOM_NAME |
	|   5 |   TABLE ACCESS BY INDEX ROWID| TELECOM_PRICE              |
	-------------------------------------------------------------------
	          0  db block gets
	         10  consistent gets
	          0  physical reads


	create index telecom_price_telecom_name
	  on telecom_price(telecom_name);
	create index emp2_telecom
	  on emp2(telecom);

	select /*+ leading(e t) use_nl(t) */
		e.ename, e.age, e.address, e.telecom, t.month_price
	  from emp2 e, telecom_price t
	  where lower( e.telecom ) = t.telecom_name
	    and e.ename = '서일';			/* 1건 */

		※ 첫 테이블을 엑세스하는 순서를 바꿨다, 왜냐하면 emp2 테이블에서 액세스해야 하는
		   데이터는 서일 데이터 한건 밖에 없기 때문이다 

	경   과: 00:00:00.01
	-------------------------------------------------------------------
	| Id  | Operation                    | Name                       |
	-------------------------------------------------------------------
	|   0 | SELECT STATEMENT             |                            |
	|   1 |  NESTED LOOPS                |                            |
	|   2 |   NESTED LOOPS               |                            |
	|*  3 |    TABLE ACCESS FULL         | EMP2                       |
	|*  4 |    INDEX RANGE SCAN          | TELECOM_PRICE_TELECOM_NAME |
	|   5 |   TABLE ACCESS BY INDEX ROWID| TELECOM_PRICE              |
	-------------------------------------------------------------------
	          0  db block gets
	          5  consistent gets
	          0  physical reads


문제 66. 직업이 SALESMAN이고 부서번호가 30번인 사원의 이름과 월급과 직업과 부서위치를 출력하시오 !
	 (조인 힌트를 사용해서 작성하시오)

	select e.ename, e.sal, e.job, d.loc
	  from emp e, dept d			/* emp 14건, dept 4건*/
	  where e.deptno = d.deptno
	    and job = 'SALESMAN'		/* 4건 */
	    and d.deptno = 30;			/* 1건 */

	ENAME                       SAL JOB                LOC
	-------------------- ---------- ------------------ ------------------------
	MARTIN                     1250 SALESMAN           CHICAGO
	ALLEN                      1600 SALESMAN           CHICAGO
	TURNER                     1500 SALESMAN           CHICAGO
	WARD                       1250 SALESMAN           CHICAGO
	
	경   과: 00:00:00.04
	---------------------------------------------------------------------------
	| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	---------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |     4 |   240 |     5  (20)| 00:00:01 |
	|*  1 |  HASH JOIN         |      |     4 |   240 |     5  (20)| 00:00:01 |
	|*  2 |   TABLE ACCESS FULL| DEPT |     1 |    21 |     2   (0)| 00:00:01 |
	|*  3 |   TABLE ACCESS FULL| EMP  |     4 |   156 |     2   (0)| 00:00:01 |
	---------------------------------------------------------------------------
	          0  db block gets
	         44  consistent gets
	          3  physical reads
	튜닝 후 :
		create index emp_deptno on emp(deptno);
		create index dept_deptno on dept(deptno);

		select /*+ leading(d e) use_nl(e) */
			e.ename, e.sal, e.job, d.loc
		  from emp e, dept d
		  where e.deptno = d.deptno
		    and job = 'SALESMAN'
		    and d.deptno = 30;

	※ 연결고리에서 인덱스가 한쪽이 없으면 없는쪽에서 시작해서 있는 쪽으로 가줘야 한다.

	ENAME                       SAL JOB                LOC
	-------------------- ---------- ------------------ --------------------------
	MARTIN                     1250 SALESMAN           CHICAGO
	ALLEN                      1600 SALESMAN           CHICAGO
	TURNER                     1500 SALESMAN           CHICAGO
	WARD                       1250 SALESMAN           CHICAGO
	
	경   과: 00:00:00.03
	-------------------------------------------------------------------------------------------
	| Id  | Operation                    | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
	-------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT             |            |     4 |   240 |     3   (0)| 00:00:01 |
	|   1 |  NESTED LOOPS                |            |       |       |            |          |
	|   2 |   NESTED LOOPS               |            |     4 |   240 |     3   (0)| 00:00:01 |
	|*  3 |    TABLE ACCESS FULL         | DEPT       |     1 |    21 |     2   (0)| 00:00:01 |
	|*  4 |    INDEX RANGE SCAN          | EMP_DEPTNO |     5 |       |     0   (0)| 00:00:01 |
	|*  5 |   TABLE ACCESS BY INDEX ROWID| EMP        |     4 |   156 |     1   (0)| 00:00:01 |
	-------------------------------------------------------------------------------------------
	          0  db block gets
	          8  consistent gets
	          0  physical reads


================================
create table bonus
as
select empno, sal * 1.2 as bonus
  from emp;
================================


문제 67. 사원이름이 ALLEN인 사원의 이름, 월급, 부서위치, 보너스(bonus)를 출력하시오 !
	 ( 조인튜닝 힌트를 사용하시오 )
	
	튜닝전 : 
		select e.ename, e.sal, d.loc, b.bonus
		  from emp e, dept d, bonus b
		  where e.deptno = d.deptno
		    and e.empno = b.empno
		    and e.ename = 'ALLEN';

	ENAME                       SAL LOC                             BONUS
	-------------------- ---------- -------------------------- ----------
	ALLEN                      1600 CHICAGO                          1920
	
	경   과: 00:00:00.01
	---------------------------------------------------------------------------------------------
	| Id  | Operation                     | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
	---------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT              |             |     1 |    93 |     6  (17)| 00:00:01 |
	|*  1 |  HASH JOIN                    |             |     1 |    93 |     6  (17)| 00:00:01 |
	|   2 |   NESTED LOOPS                |             |       |       |            |          |
	|   3 |    NESTED LOOPS               |             |     1 |    67 |     3   (0)| 00:00:01 |
	|*  4 |     TABLE ACCESS FULL         | EMP         |     1 |    46 |     2   (0)| 00:00:01 |
	|*  5 |     INDEX RANGE SCAN          | DEPT_DEPTNO |     1 |       |     0   (0)| 00:00:01 |
	|   6 |    TABLE ACCESS BY INDEX ROWID| DEPT        |     1 |    21 |     1   (0)| 00:00:01 |
	|   7 |   TABLE ACCESS FULL           | BONUS       |    14 |   364 |     2   (0)| 00:00:01 |
	---------------------------------------------------------------------------------------------
	          0  db block gets
	          9  consistent gets
	          0  physical reads

	튜닝 후 :
		alter table emp
		  add constraint emp_empno_pk primary key(empno);

		alter table bonus
		  add constraint bonus_empno_pk primary key(empno);

		select /*+ leading(e d b) use_nl(d) use_nl(b) */
			e.ename, e.sal, d.loc, b.bonus
		  from emp e, dept d, bonus b
		  where e.deptno = d.deptno
		    and e.empno = b.empno
		    and e.ename = 'ALLEN';

	ENAME                       SAL LOC                             BONUS
	-------------------- ---------- -------------------------- ----------
	ALLEN                      1600 CHICAGO                          1920
	
	경   과: 00:00:00.00
	-------------------------------------------------------------------------------------------------
	| Id  | Operation                      | Name           | Rows  | Bytes | Cost (%CPU)| Time     |
	-------------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT               |                |     1 |    93 |     4   (0)| 00:00:01 |
	|   1 |  NESTED LOOPS                  |                |       |       |            |          |
	|   2 |   NESTED LOOPS                 |                |     1 |    93 |     4   (0)| 00:00:01 |
	|   3 |    NESTED LOOPS                |                |     1 |    67 |     3   (0)| 00:00:01 |
	|*  4 |     TABLE ACCESS FULL          | EMP            |     1 |    46 |     2   (0)| 00:00:01 |
	|   5 |     TABLE ACCESS BY INDEX ROWID| DEPT           |     1 |    21 |     1   (0)| 00:00:01 |
	|*  6 |      INDEX RANGE SCAN          | DEPT_DEPTNO    |     1 |       |     0   (0)| 00:00:01 |
	|*  7 |    INDEX UNIQUE SCAN           | BONUS_EMPNO_PK |     1 |       |     0   (0)| 00:00:01 |
	|   8 |   TABLE ACCESS BY INDEX ROWID  | BONUS          |     1 |    26 |     1   (0)| 00:00:01 |
	-------------------------------------------------------------------------------------------------
	          0  db block gets
	          9  consistent gets
	          0  physical reads










■ 서브쿼리 문장 튜닝

	* 서브쿼리 문장의 튜닝 방법 2가지

		1. 순수하게 서브쿼리로 수행하면서 튜닝		: no_unnest (감싸라)
			- 서브쿼리부터 수행			: push_subq
			- 메인쿼리부터 수행			: no_push_subq

			※ 힌트를 서브쿼리에 써준다.

		2. 서브쿼리를 조인으로 변경해서 튜닝		: unnest (감싸지마라)
			- in 사용시
				(1) nested loop semi join 	: nl_sj
				(2) hash sami join		: hash_sj
				(3) merge semi join		: merge_sj

			※ 세미조인(semi join) ? 절반의 조인
				완전한 조인이 아니라 절반의 조인인 이유는
				조인 방법은 3가지중에 아무거나 다 사용할 수 있는데
				조인 순서는 고정이 된다.
				(메인 쿼리 테이블 ----> 서브쿼리 테이블로 고정됨)


			- not in 사용시
				(1) nested loop anti join	: nl_aj
				(2) hash anti join		: hash_aj
				(3) merge anti join		: merge_aj

		 * 해쉬 안티조인은 ?
			세미조인처럼 완전한 조인이 아니라 절반의 조인인데
			즉 메인쿼리의 테이블부터 엑세스하고 서브쿼리의 테이블을 엑세스하는 고정된 
			조인순서를 갖는 실행계획인데 in 아니라 not in 을 사용한 경우의 실행계획이다.

	※ 서브쿼리 메인쿼리 둘중 한쪽이 대용량인경우 소용량인 쿼리부터 풀게 서브쿼리문을 사용하지만
	   둘다 대용량이라면 조인으로 푸는 것이 더 현명하다

	※ 서브쿼리문 튜닝 방법 정리
		서브쿼리문의 데이터가 적을때는 순수하게 서브쿼리로 수행되는게 좋은 성능을 보이나 대용량
		테이블일 경우에는 해쉬 세미 조인으로 수행되게끔 힌트를 주면 유리하다.
		그리고 swap_join_inputs 힌트를 이용해서 작은 테이블 부터 드라이빙 되게끔 조정할 수 있다.

	※ 해쉬 안티조인을 하려면 메인쿼리 서브쿼리 둘 다에 연결 고리가 되는 컬럼에 null이 없다는 조건을
	   걸어줘야 한다.


문제 68. SCOTT과 같은 월급을 받는 사원의 이름과 월급을 출력하시오 !

	select ename, sal
	  from emp
	  where sal = (select sal
			 from emp
			 where ename = 'SCOTT');

	ENAME                       SAL
	-------------------- ----------
	FORD                       3000
	SCOTT                      3000
	
	경   과: 00:00:00.03
	---------------------------------------------------------------------------
	| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	---------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |     1 |    20 |     4   (0)| 00:00:01 |
	|*  1 |  TABLE ACCESS FULL | EMP  |     1 |    20 |     2   (0)| 00:00:01 |
	|*  2 |   TABLE ACCESS FULL| EMP  |     1 |    20 |     2   (0)| 00:00:01 |
	---------------------------------------------------------------------------
	          0  db block gets
	          7  consistent gets
	          0  physical reads
	※ 실행계획을 보면 서브쿼리부터 실행되었는지 알 수 있는 방법이 없다.
	   그래서 힌트를 적어준다 ( qb_name( ) : 쿼리에 이름을 붙여주는 힌트)
	 * 실행 계획의 종류 2가지
		1. 예측 실행 계획 : SQL을 실행해보기 전에 미리 예측한 실행계획
		2. 실제 실행 계획 : SQL을 실행하고 실행할 때 사용했던 실행계획
	※ qb_name 힌트에 대한 결과는 실제 실행계획에서만 볼 수 있다.

		select /*+ qb_name(main) */ 
			ename, sal
		  from emp
		  where sal = (select /*+ qb_name(sub) */ sal
				 from emp
				 where ename = 'SCOTT');
	
	----------------------------------------------------------------------------
	| Id  | Operation          | Name | E-Rows |E-Bytes| Cost (%CPU)| E-Time   |
	----------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |        |       |     4 (100)|          |
	|*  1 |  TABLE ACCESS FULL | EMP  |      1 |    20 |     2   (0)| 00:00:01 |
	|*  2 |   TABLE ACCESS FULL| EMP  |      1 |    20 |     2   (0)| 00:00:01 |
	----------------------------------------------------------------------------
	 
	Query Block Name / Object Alias (identified by operation id):
	-------------------------------------------------------------
	 
	   1 - MAIN / EMP@MAIN
	   2 - SUB  / EMP@SUB


문제 69. 위의 실행계획이 main query 부터 수행되게 하시오 !

		select /*+ qb_name(main) */ 
			ename, sal
		  from emp
		  where sal = (select /*+ qb_name(sub) no_push_subq */ sal
				 from emp
				 where ename = 'SCOTT');
	
	----------------------------------------------------------------------------
	| Id  | Operation          | Name | E-Rows |E-Bytes| Cost (%CPU)| E-Time   |
	----------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |        |       |     4 (100)|          |
	|*  1 |  FILTER            |      |        |       |            |          |
	|   2 |   TABLE ACCESS FULL| EMP  |     14 |   280 |     2   (0)| 00:00:01 |
	|*  3 |   TABLE ACCESS FULL| EMP  |      1 |    20 |     2   (0)| 00:00:01 |
	----------------------------------------------------------------------------
	 
	Query Block Name / Object Alias (identified by operation id):
	-------------------------------------------------------------
	 
	   1 - MAIN
	   2 - MAIN / EMP@MAIN
	   3 - SUB  / EMP@SUB


문제 70. 아래의 SQL을 서브쿼리부터 수행되게도 해보고 메인쿼리부터 수행되게도 해보시오 !

	select count(*)
	  from sales100
	  where time_id in ( select time_id
				from times100
				where week_ending_day_id = 1581);
	----------------------------------------------------------------------
	| Id  | Operation                      | Name                        |
	----------------------------------------------------------------------
	|   0 | SELECT STATEMENT               |                             |
	|   1 |  SORT AGGREGATE                |                             |
	|   2 |   NESTED LOOPS                 |                             |
	|   3 |    SORT UNIQUE                 |                             |
	|   4 |     TABLE ACCESS BY INDEX ROWID| TIMES100                    |
	|*  5 |      INDEX RANGE SCAN          | TIMES100_WEEK_ENDING_DAY_ID |
	|*  6 |    INDEX RANGE SCAN            | SALES100_TIME_ID            |
	----------------------------------------------------------------------

	- 서브쿼리부터 수행
	select count(*)
	  from sales100
	  where time_id in ( select /*+ no_unnest push_subq */ time_id
				from times100
				where week_ending_day_id = 1581);
	  COUNT(*)
	----------
	      3490
	
	경   과: 00:00:03.20
	--------------------------------------------------------------------------------
	| Id  | Operation           | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
	--------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT    |          |     1 |     9 |  1397   (1)| 00:00:17 |
	|   1 |  SORT AGGREGATE     |          |     1 |     9 |            |          |
	|*  2 |   TABLE ACCESS FULL | SALES100 | 47399 |   416K|  1379   (1)| 00:00:17 |
	|*  3 |    TABLE ACCESS FULL| TIMES100 |     1 |    22 |    18   (0)| 00:00:01 |
	--------------------------------------------------------------------------------
	          0  db block gets
	    1952009  consistent gets
	       5060  physical reads

	- 메인쿼리부터 수행
	select count(*)
	  from sales100
	  where time_id in ( select /*+ no_unnest no_pusj_subq */ time_id
				from times100
				where week_ending_day_id = 1581);
	  COUNT(*)
	----------
	      3490
	
	경   과: 00:00:03.23
	--------------------------------------------------------------------------------
	| Id  | Operation           | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
	--------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT    |          |     1 |     9 |    13M  (1)| 44:46:00 |
	|   1 |  SORT AGGREGATE     |          |     1 |     9 |            |          |
	|*  2 |   FILTER            |          |       |       |            |          |
	|   3 |    TABLE ACCESS FULL| SALES100 |   947K|  8331K|  1379   (1)| 00:00:17 |
	|*  4 |    TABLE ACCESS FULL| TIMES100 |     1 |    22 |    18   (0)| 00:00:01 |
	--------------------------------------------------------------------------------
	          0  db block gets
	    1952009  consistent gets
	       5060  physical reads




========
@demobld
========


문제 71. 아래의 SQL이 순수하게 서브쿼리로 수행되게 하고 서브쿼리부터 실행되게 하시오 !

		select ename, sal, job
		  from emp
		  where deptno in ( select deptno from dept) ;

	경   과: 00:00:00.05
	---------------------------------------------------------------------------
	| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	---------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |    14 |   728 |     5  (20)| 00:00:01 |
	|*  1 |  HASH JOIN SEMI    |      |    14 |   728 |     5  (20)| 00:00:01 |
	|   2 |   TABLE ACCESS FULL| EMP  |    14 |   546 |     2   (0)| 00:00:01 |
	|   3 |   TABLE ACCESS FULL| DEPT |     4 |    52 |     2   (0)| 00:00:01 |
	---------------------------------------------------------------------------
	          0  db block gets
	          7  consistent gets
	          0  physical reads

		select ename, sal, job
		  from emp
		  where deptno in ( select /*+ no_unnest push_subq */deptno from dept) ;

	경   과: 00:00:00.04
	---------------------------------------------------------------------------
	| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	---------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |     1 |    39 |     4   (0)| 00:00:01 |
	|*  1 |  TABLE ACCESS FULL | EMP  |     1 |    39 |     2   (0)| 00:00:01 |
	|*  2 |   TABLE ACCESS FULL| DEPT |     1 |    13 |     2   (0)| 00:00:01 |
	---------------------------------------------------------------------------
	          0  db block gets
	         21  consistent gets
	          0  physical reads


문제 72. 위의 SQL이 메인쿼리부터 수행되게 하시오 !

		select ename, sal, job
		  from emp
		  where deptno in (select /*+ no_unnest no_push_subq */ deptno from dept);

	경   과: 00:00:00.04
	---------------------------------------------------------------------------
	| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	---------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |    14 |   546 |     4   (0)| 00:00:01 |
	|*  1 |  FILTER            |      |       |       |            |          |
	|   2 |   TABLE ACCESS FULL| EMP  |    14 |   546 |     2   (0)| 00:00:01 |
	|*  3 |   TABLE ACCESS FULL| DEPT |     1 |    13 |     2   (0)| 00:00:01 |
	---------------------------------------------------------------------------
	          0  db block gets
	         13  consistent gets
	          0  physical reads

	※ 웬만하면 서브쿼리부터 수행되게 하는 것이 빠르다.

	★★★ push_subq 나 no_push_subq힌트를 사용하려면 no_unnest 와 같이 사용해야 한다.


문제 73. 안혜진 학생과 같은 전공인 학생들의 이름과 전공을 출력하시오 !
	(실행계획을 서브쿼리부터 수행되게 하시오 !)

	select ename, major
	  from emp2
	  where major = (select /*+ no_unnest push_subq */ major from emp2 where ename = '안혜진');

	경   과: 00:00:00.02
	---------------------------------------------------------------------------
	| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	---------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |     1 |    24 |     4   (0)| 00:00:01 |
	|*  1 |  TABLE ACCESS FULL | EMP2 |     1 |    24 |     2   (0)| 00:00:01 |
	|*  2 |   TABLE ACCESS FULL| EMP2 |     1 |    24 |     2   (0)| 00:00:01 |
	---------------------------------------------------------------------------
	          0  db block gets
	          5  consistent gets
	          0  physical reads

	※ 별다른 힌트를 안줘도 잘 수행한다 왜냐하면 (=)을 써서 1개만 리턴하기 때문이다.
		하지만 in을 쓰게 된다면 여러개를 리턴하기 때문에 대용량이라 판단하고 
		옵티마이저가 조인문으로 바꿔버린다.



문제 74. 아래의 SQL이 조인으로 풀리게 힌트를 주고 조인방법중에 nested loop join이 되게 하시오 !

	select ename, sal, job
	  from emp
	  where deptno in ( select deptno from dept );

	select ename, sal, job
	  from emp
	  where deptno in ( select /*+ unnest nl_sj */deptno from dept );

	경   과: 00:00:00.04
	---------------------------------------------------------------------------
	| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	---------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |    14 |   728 |     8   (0)| 00:00:01 |
	|   1 |  NESTED LOOPS SEMI |      |    14 |   728 |     8   (0)| 00:00:01 |
	|   2 |   TABLE ACCESS FULL| EMP  |    14 |   546 |     2   (0)| 00:00:01 |
	|*  3 |   TABLE ACCESS FULL| DEPT |     4 |    52 |     0   (0)| 00:00:01 |
	---------------------------------------------------------------------------
	          0  db block gets
	         13  consistent gets
	          0  physical reads	

	서브쿼리로 수행되는 SQL이 양쪽 다 대용량이면 서브쿼리로 수행되는것 보다는 조인으로 수행되게 
	하는 것이 더 성능이 좋다. 조인 방법중에 해쉬조인을 사용할 수 있기 때문이다.

	※ 서브쿼리 메인쿼리 둘중 한쪽이 대용량인경우 소용량인 쿼리부터 풀게 서브쿼리문을 사용하지만
	   둘다 대용량이라면 조인으로 푸는 것이 더 현명하다

	select ename, sal, job
	  from emp
	  where deptno in ( select /*+ unnest hash_sj */deptno from dept );

	경   과: 00:00:00.04
	---------------------------------------------------------------------------
	| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	---------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |    14 |   728 |     5  (20)| 00:00:01 |
	|*  1 |  HASH JOIN SEMI    |      |    14 |   728 |     5  (20)| 00:00:01 |
	|   2 |   TABLE ACCESS FULL| EMP  |    14 |   546 |     2   (0)| 00:00:01 |
	|   3 |   TABLE ACCESS FULL| DEPT |     4 |    52 |     2   (0)| 00:00:01 |
	---------------------------------------------------------------------------
	          0  db block gets
	         15  consistent gets
	          0  physical reads


문제 75. 위의 해쉬세미조인의 조인순서를 dept ----> emp 로 변경하시오 !

	select ename, sal, job
	  from emp
	  where deptno in ( select /*+ unnest hash_sj swap_join_inputs(d) */deptno from dept d);
	
	경   과: 00:00:00.04
	-----------------------------------------------------------------------------
	| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	-----------------------------------------------------------------------------
	|   0 | SELECT STATEMENT     |      |    14 |   728 |     5  (20)| 00:00:01 |
	|*  1 |  HASH JOIN RIGHT SEMI|      |    14 |   728 |     5  (20)| 00:00:01 |
	|   2 |   TABLE ACCESS FULL  | DEPT |     4 |    52 |     2   (0)| 00:00:01 |
	|   3 |   TABLE ACCESS FULL  | EMP  |    14 |   546 |     2   (0)| 00:00:01 |
	-----------------------------------------------------------------------------
	          0  db block gets
	         15  consistent gets
	          0  physical reads


문제 76. 아래의 SQL을 hash join right semi 조인이 되게 하시오 !

	튜닝전 : 
		select count(*)
		  from sales100
		  where time_id in ( select /*+ no_unnest no_push_subq */ time_id
					from times100
					where week_ending_day_id = 1581 );

	경   과: 00:00:03.26
	--------------------------------------------------------------------------------
	| Id  | Operation           | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
	--------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT    |          |     1 |     9 |    13M  (1)| 44:46:00 |
	|   1 |  SORT AGGREGATE     |          |     1 |     9 |            |          |
	|*  2 |   FILTER            |          |       |       |            |          |
	|   3 |    TABLE ACCESS FULL| SALES100 |   947K|  8331K|  1379   (1)| 00:00:17 |
	|*  4 |    TABLE ACCESS FULL| TIMES100 |     1 |    22 |    18   (0)| 00:00:01 |
	--------------------------------------------------------------------------------
	          0  db block gets
	    1952009  consistent gets
	       5060  physical reads

		select count(*)
		  from sales100
		  where time_id in ( select /*+ unnest hash_sj swap_join_inputs(times100) */ time_id
					from times100
					where week_ending_day_id = 1581 );

	경   과: 00:00:00.22
	----------------------------------------------------------------------------------
	| Id  | Operation             | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
	----------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT      |          |     1 |    31 |  1400   (1)| 00:00:17 |
	|   1 |  SORT AGGREGATE       |          |     1 |    31 |            |          |
	|*  2 |   HASH JOIN RIGHT SEMI|          | 13272 |   401K|  1400   (1)| 00:00:17 |
	|*  3 |    TABLE ACCESS FULL  | TIMES100 |     7 |   154 |    18   (0)| 00:00:01 |
	|   4 |    TABLE ACCESS FULL  | SALES100 |   947K|  8331K|  1379   (1)| 00:00:17 |
	----------------------------------------------------------------------------------
	          0  db block gets
	       5127  consistent gets
	       5060  physical reads


문제 77. 아래와 같이 실행계획이 나오게 하시오 !

	----------------------------------------------------------------------------------------
	| Id  | Operation           | Name     | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
	----------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT    |          |     1 |    31 |       |  2343   (1)| 00:00:29 |
	|   1 |  SORT AGGREGATE     |          |     1 |    31 |       |            |          |
	|*  2 |   HASH JOIN SEMI    |          | 13272 |   401K|    18M|  2343   (1)| 00:00:29 |
	|   3 |    TABLE ACCESS FULL| SALES100 |   947K|  8331K|       |  1379   (1)| 00:00:17 |
	|*  4 |    TABLE ACCESS FULL| TIMES100 |     7 |   154 |       |    18   (0)| 00:00:01 |
	----------------------------------------------------------------------------------------

		select /*+ leading(s t) */ count(*)
		  from sales100 s
		  where time_id in ( select /*+ unnest hash_sj swap_join_inputs(s) */ time_id
					from times100 t
					where week_ending_day_id = 1581 );

	※ 왠만하면 서브쿼리쪽에 힌트를 작성하는데 만약 원하는 결과가 나오지 않는다면
	   메인쿼리에도 써봐라!



문제 78. 관리자가 아닌 사원들의 이름을 출력하시오 !
	 (자기 밑에 직속부하가 한명도 없는 사원들)

	select ename 
	  from emp
	  where empno not in ( select nvl(mgr,0) from emp);

	select ename 
	  from emp
	  where empno not in ( select /*+ unnest hash_aj */ nvl(mgr,0) from emp);

	경   과: 00:00:00.03
	---------------------------------------------------------------------------
	| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	---------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |    14 |   462 |     5  (20)| 00:00:01 |
	|*  1 |  HASH JOIN ANTI    |      |    14 |   462 |     5  (20)| 00:00:01 |
	|   2 |   TABLE ACCESS FULL| EMP  |    14 |   280 |     2   (0)| 00:00:01 |
	|   3 |   TABLE ACCESS FULL| EMP  |    14 |   182 |     2   (0)| 00:00:01 |
	---------------------------------------------------------------------------
	          0  db block gets
	         14  consistent gets
	          0  physical reads


문제 79. 아래의 SQL을 해쉬 안티 조인이 되게 하시오 !

	select *
	  from emp
	  where deptno not in (select deptno from dept);

	경   과: 00:00:00.01
	---------------------------------------------------------------------------
	| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	---------------------------------------------------------------------------
	|   0 | SELECT STATEMENT   |      |    14 |  1400 |     5  (20)| 00:00:01 |
	|*  1 |  HASH JOIN ANTI NA |      |    14 |  1400 |     5  (20)| 00:00:01 |
	|   2 |   TABLE ACCESS FULL| EMP  |    14 |  1218 |     2   (0)| 00:00:01 |
	|   3 |   TABLE ACCESS FULL| DEPT |     4 |    52 |     2   (0)| 00:00:01 |
	---------------------------------------------------------------------------
	          0  db block gets
	         14  consistent gets
	          0  physical reads


문제 80. 위의 SQL의 실행계획이 아래와 같이 되게 하시오 !

	select /*+ leading(d e) */ *
	  from emp e
	  where deptno not in (select /*+ unnest hash_aj swap_join_inputs(d) */ deptno 
				 from dept d
				 where deptno is not null)
	    and deptno is not null;	

	※ 해쉬 안티조인을 하려면 메인쿼리 서브쿼리 둘 다에 연결 고리가 되는 컬럼에 null이 없다는 조건을
	   걸어줘야 한다.
	 * 해쉬 안티조인은 ?
		세미조인처럼 완전한 조인이 아니라 절반의 조인인데
		즉 메인쿼리의 테이블부터 엑세스하고 서브쿼리의 테이블을 엑세스하는 고정된 조인순서를
		갖는 실행계획인데 in 아니라 not in 을 사용한 경우의 실행계획이다.

	경   과: 00:00:00.01
	-----------------------------------------------------------------------------
	| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |
	-----------------------------------------------------------------------------
	|   0 | SELECT STATEMENT     |      |    14 |  1400 |     5  (20)| 00:00:01 |
	|*  1 |  HASH JOIN RIGHT ANTI|      |    14 |  1400 |     5  (20)| 00:00:01 |
	|*  2 |   TABLE ACCESS FULL  | DEPT |     4 |    52 |     2   (0)| 00:00:01 |
	|*  3 |   TABLE ACCESS FULL  | EMP  |    14 |  1218 |     2   (0)| 00:00:01 |
	-----------------------------------------------------------------------------
	          0  db block gets
	         14  consistent gets
	          0  physical reads













■ 기타 SQL 튜닝 방법


문제 81. 아래의 SQL을 분석함수를 이용하지 않은 SQL로 작성하시오 !
	(오늘의 마지막 문제)

	전 : 
		select empno, ename, sal, sum(sal) over (order by empno) 누적치
		  from emp;

	후 :	
		with emp_sal as (select rownum as rn, e.* 
				   from (select empno, ename, sal 
					   from emp 
					   order by sal) e)
		select e1.empno, e1.ename, e1.sal,
		 	(select sum(sal) 
			   from emp_sal e2
			   where e2.rn <= e1.rn) 누적치
		  from emp_sal e1;


		select empno, ename, sal, (select sum(sal) 
					     from emp ee 
					     where ee.empno <= e.empno) 누적치
		  from emp e
		  order by empno;



